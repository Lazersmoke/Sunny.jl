<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library API Â· Sunny documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Sunny documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../quick-start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/fei2_tutorial/">Case Study: FeI<span>$_{2}$</span></a></li><li><a class="tocitem" href="../examples/powder_averaging/">Powder Averaging</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library API</a><ul class="internal"><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../structure-factor/">Structure Factor Calculations</a></li><li><a class="tocitem" href="../versions/">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-API"><a class="docs-heading-anchor" href="#Library-API">Library API</a><a id="Library-API-1"></a><a class="docs-heading-anchor-permalink" href="#Library-API" title="Permalink"></a></h1><p>This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter <code>?</code> at the Julia command prompt).</p><ul><li><a href="#Sunny.Units"><code>Sunny.Units</code></a></li><li><a href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a></li><li><a href="#Sunny.ğ’ª"><code>Sunny.ğ’ª</code></a></li><li><a href="#Sunny.ğ’®"><code>Sunny.ğ’®</code></a></li><li><a href="#Sunny.Bond"><code>Sunny.Bond</code></a></li><li><a href="#Sunny.Crystal"><code>Sunny.Crystal</code></a></li><li><a href="#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}"><code>Sunny.FormFactor</code></a></li><li><a href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a></li><li><a href="#Sunny.Langevin"><code>Sunny.Langevin</code></a></li><li><a href="#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a></li><li><a href="#Sunny.Site"><code>Sunny.Site</code></a></li><li><a href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a></li><li><a href="#Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.StructureFactor</code></a></li><li><a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a></li><li><a href="#Sunny.DynamicStructureFactor-Tuple{System}"><code>Sunny.DynamicStructureFactor</code></a></li><li><a href="#Sunny.InstantStructureFactor-Tuple{System}"><code>Sunny.InstantStructureFactor</code></a></li><li><a href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>Sunny.add_sample!</code></a></li><li><a href="#Sunny.all_exact_wave_vectors-Tuple{StructureFactor}"><code>Sunny.all_exact_wave_vectors</code></a></li><li><a href="#Sunny.broaden_energy-Tuple{StructureFactor, Any, Function}"><code>Sunny.broaden_energy</code></a></li><li><a href="#Sunny.browser-Tuple{String}"><code>Sunny.browser</code></a></li><li><a href="#Sunny.connected_path-Tuple{Vector, Any}"><code>Sunny.connected_path</code></a></li><li><a href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a></li><li><a href="#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.enable_dipole_dipole!</code></a></li><li><a href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a></li><li><a href="#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.forces</code></a></li><li><a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.instant_intensities</code></a></li><li><a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.intensities</code></a></li><li><a href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a></li><li><a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a></li><li><a href="#Sunny.lorentzian-Tuple{Any, Any}"><code>Sunny.lorentzian</code></a></li><li><a href="#Sunny.plot_spins-Tuple{System}"><code>Sunny.plot_spins</code></a></li><li><a href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>Sunny.print_anisotropy_as_classical_spins</code></a></li><li><a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>Sunny.print_anisotropy_as_stevens</code></a></li><li><a href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a></li><li><a href="#Sunny.print_dominant_wavevectors-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.print_dominant_wavevectors</code></a></li><li><a href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a></li><li><a href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a></li><li><a href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a></li><li><a href="#Sunny.propose_delta-Tuple{Any}"><code>Sunny.propose_delta</code></a></li><li><a href="#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.propose_flip</code></a></li><li><a href="#Sunny.propose_mix-Tuple{Any, Any}"><code>Sunny.propose_mix</code></a></li><li><a href="#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a></li><li><a href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a></li><li><a href="#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.repeat_periodically</code></a></li><li><a href="#Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.reshape_geometry</code></a></li><li><a href="#Sunny.resize_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.resize_periodically</code></a></li><li><a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>Sunny.set_anisotropy!</code></a></li><li><a href="#Sunny.set_anisotropy_at!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N"><code>Sunny.set_anisotropy_at!</code></a></li><li><a href="#Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_biquadratic!</code></a></li><li><a href="#Sunny.set_biquadratic_at!-Union{Tuple{N}, Tuple{System{N}, Any, Bond, Any}} where N"><code>Sunny.set_biquadratic_at!</code></a></li><li><a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a></li><li><a href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Bond, Any}} where N"><code>Sunny.set_exchange_at!</code></a></li><li><a href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a></li><li><a href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a></li><li><a href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a></li><li><a href="#Sunny.spherical_shell-Tuple{StructureFactor, Any, Any}"><code>Sunny.spherical_shell</code></a></li><li><a href="#Sunny.step!-Tuple{System{0}, Langevin}"><code>Sunny.step!</code></a></li><li><a href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a></li><li><a href="#Sunny.suggest_magnetic_supercell-Tuple{Any, Any}"><code>Sunny.suggest_magnetic_supercell</code></a></li><li><a href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.to_inhomogeneous</code></a></li><li><a href="#Sunny.view_crystal-Tuple{Crystal, Real}"><code>Sunny.view_crystal</code></a></li><li><a href="#Sunny.Ï‰s-Tuple{StructureFactor}"><code>Sunny.Ï‰s</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Sunny.Units" href="#Sunny.Units"><code>Sunny.Units</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Units.meV
Units.theory</code></pre><p>The unit system is implicitly determined by the definition of two physical constants: the vacuum permeability <span>$Î¼â‚€$</span> and the Bohr magneton <span>$Î¼_B$</span>. Temperatures are effectively measured in units of energy (<span>$k_B = 1$</span>) and time is effectively measured in units of inverse energy (<span>$Ä§ = 1$</span>). The default unit system, <code>Units.meV</code>, employs (meV, â„«, tesla). Select alternatively <code>Units.theory</code> for a units system defined so that <span>$Î¼â‚€ = Î¼_B = 1$</span>.</p><p>See also <a href="#Sunny.meV_per_K"><code>meV_per_K</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Units.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.meV_per_K" href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">meV_per_K = 0.086173332621451774</code></pre><p>A physical constant. Useful for converting kelvin into the default energy units, meV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Units.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ğ’ª" href="#Sunny.ğ’ª"><code>Sunny.ğ’ª</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ğ’ª[k,q]</code></pre><p>Abstract symbols for the Stevens operators. Linear combinations of these can be used to define a single-ion anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/LocalOperators.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ğ’®" href="#Sunny.ğ’®"><code>Sunny.ğ’®</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ğ’®[1], ğ’®[2], ğ’®[3]</code></pre><p>Abstract symbols for the spin operators. Polynomials of these can be used to define a single-ion anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/LocalOperators.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Bond" href="#Sunny.Bond"><code>Sunny.Bond</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bond(i, j, n)</code></pre><p>Represents a bond between atom indices <code>i</code> and <code>j</code>. <code>n</code> is a vector of three integers specifying unit cell displacement in terms of lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/Bond.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Crystal" href="#Sunny.Crystal"><code>Sunny.Crystal</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:</p><pre><code class="nohighlight hljs">Crystal(filename; symprec=1e-5)</code></pre><p>Reads the crystal from a <code>.cif</code> file located at the path <code>filename</code>.  The optional parameter <code>symprec</code> controls the precision tolerance for spacegroup symmetries.</p><pre><code class="nohighlight hljs">Crystal(lat_vecs, positions; types=nothing, symprec=1e-5)</code></pre><p>Constructs a crystal from the complete list of atom positions <code>positions</code>, with coordinates (between 0 and 1) in units of lattice vectors <code>lat_vecs</code>. Spacegroup symmetry information is automatically inferred. The optional parameter <code>types</code> is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.</p><pre><code class="nohighlight hljs">Crystal(lat_vecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)</code></pre><p>Builds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional <code>setting</code> string will disambiguate between unit cell conventions.</p><p>Currently, crystals built using only the spacegroup number will be missing some symmetry information. It is generally preferred to build a crystal from a <code>.cif</code> file or from the full specification of the unit cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read a Crystal from a .cif file
Crystal(&quot;filename.cif&quot;)

# Build an FCC crystal using the primitive unit cell. The spacegroup number
# 225 is inferred.
lat_vecs = [1 1 0;
            1 0 1;
            0 1 1] / 2
positions = [[0, 0, 0]]
Crystal(lat_vecs, positions)

# Build a CsCl crystal (two cubic sublattices). By providing distinct type
# strings, the spacegroup number 221 is inferred.
lat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[0,0,0], [0.5,0.5,0.5]]
types = [&quot;Na&quot;, &quot;Cl&quot;]
cryst = Crystal(lat_vecs, positions; types)

# Build a diamond cubic crystal from its spacegroup number 227. This
# spacegroup has two possible settings (&quot;1&quot; or &quot;2&quot;), which determine an
# overall unit cell translation.
lat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[1, 1, 1] / 4]
cryst = Crystal(lat_vecs, positions, 227; setting=&quot;1&quot;)</code></pre><p>See also <a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/Crystal.jl#L8-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}" href="#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}"><code>Sunny.FormFactor</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FormFactor(atom::Int64, elem::String; g_lande=nothing)</code></pre><p>Basic type for specifying form factor parameters. Must be provided a site within the unit cell (<code>atom</code>) and a string specifying the element name. This used when calling <a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>intensities</code></a>, which requires a list of <code>FormFactors</code>s.</p><p>A list of supported element names is available at:</p><p>https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html</p><p>The LandÃ© g-factor may also be specified. </p><p>In more detail, the data stored in a <code>FormFactor</code> will be used to compute the form factor for each momentum space magnitude <code>|k|</code>, measured in inverse angstroms. The result is dependent on the magnetic ion species. By default, a first order form factor <span>$f$</span> is returned. If the keyword <code>g_lande</code> is given a numerical value, then a second order form factor <span>$F$</span> is returned.</p><p>It is traditional to define the form factors using a sum of Gaussian broadening functions in the scalar variable <span>$s = |k|/4Ï€$</span>, where <span>$|k|$</span> can be interpreted as the magnitude of momentum transfer.</p><p>The Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors, defines the approximation</p><p><span>$\langle j_l(s) \rangle = A e^{-as^2} + B e^{-bs^2} + Ce^{-cs^2} + D,$</span></p><p>where coefficients <span>$A, B, C, D, a, b, c$</span> are obtained from semi-empirical fits, depending on the orbital angular momentum index <span>$l = 0, 2$</span>. For transition metals, the form-factors are calculated using the Hartree-Fock method. For rare-earth metals and ions, Dirac-Fock form is used for the calculations.</p><p>A first approximation to the magnetic form factor is</p><p><span>$f(s) = \langle j_0(s) \rangle$</span></p><p>A second order correction is given by</p><p><span>$F(s) = \frac{2-g}{g} \langle j_2(s) \rangle s^2 + f(s)$</span>, where <span>$g$</span> is the LandÃ© g-factor.  </p><p>Digital tables are available at:</p><ul><li>https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html</li></ul><p>Additional references are:</p><ul><li>Marshall W and Lovesey S W, Theory of thermal neutron scattering Chapter 6 Oxford University Press (1971)</li><li>Clementi E and Roetti C,  Atomic Data and Nuclear Data Tables, 14 pp 177-478 (1974)</li><li>Freeman A J and Descleaux J P, J. Magn. Mag. Mater., 12 pp 11-21 (1979)</li><li>Descleaux J P and Freeman A J, J. Magn. Mag. Mater., 8 pp 119-129 (1978) </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/FormFactor.jl#L12-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ImplicitMidpoint" href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImplicitMidpoint(Î”t::Float64; atol=1e-12) where N</code></pre><p>Energy-conserving integrator for simulating dynamics without damping or noise. Use with the <code>step!</code> function to evolve a <code>System</code> forward by a time step of <code>Î”t</code>:</p><p>step!(sys::System, integrator::ImplicitMidpoint)</p><p>The above function will use the spherical midpoint integration scheme for dipole systems and the Schrodinger midpoint integration scheme for SU(N) spin systems. Both integration schemes are symplectic (energy-conserving) and are appropriate for simulating dissipationless dynamics over long periods of time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Integrators.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Langevin" href="#Sunny.Langevin"><code>Sunny.Langevin</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Langevin(Î”t::Float64; Î»::Float64, kT::Float64)</code></pre><p>Projected Heun integration scheme with noise and damping. Use with the <code>step!</code> function to evolve a <code>System</code> forward by a time step of <code>Î”t</code>:</p><p>step!(sys::System, integrator::Langevin)</p><p>If <code>kT &gt; 0</code>, this will simulate dynamics in the presence of a thermal bath. <code>Î»</code> is an empirical parameter that determines the strength of coupling to the thermal bath and sets a time scale for decorrelation, <code>1/Î»</code>. Both keyword parameters are required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Integrators.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.LocalSampler" href="#Sunny.LocalSampler"><code>Sunny.LocalSampler</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalSampler(; kT, nsweeps=1.0, propose=propose_uniform)</code></pre><p>Monte Carlo simulation involving Metropolis updates to individual spins. Use with the <a href="#Sunny.step!-Tuple{System{0}, Langevin}"><code>step!</code></a> function.</p><ul><li><code>kT</code> is the target temperature, and can be updated dynamically.</li><li><code>nsweeps</code> is the number of full-system MCMC sweeps, and may be fractional. The default value of <code>1.0</code> means that <code>step!</code> performs, on average, one trial update for every spin.</li><li><code>propose</code> is a function to generate new candidate spin states, which may be accepted or rejected. Options include <a href="#Sunny.propose_uniform"><code>propose_uniform</code></a>, <a href="#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>propose_flip</code></a>, and <a href="#Sunny.propose_delta-Tuple{Any}"><code>propose_delta</code></a>. Multiple proposals can be mixed with <a href="#Sunny.propose_mix-Tuple{Any, Any}"><code>propose_mix</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Samplers.jl#L81-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Site" href="#Sunny.Site"><code>Sunny.Site</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(cell1, cell2, cell3, i) :: Site</code></pre><p>Four indices that identify a single site in a <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>. The first three indices select the lattice cell and the last selects the sublattice (i.e., the atom within the unit cell).</p><p>This object can be used to index <code>dipoles</code> and <code>coherents</code> fields of a <code>System</code>. A <code>Site</code> is also required to specify inhomogeneous interactions via functions such as <a href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>set_external_field_at!</code></a> or <a href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Bond, Any}} where N"><code>set_exchange_at!</code></a>.</p><p>Note that the definition of a cell may change when a system is reshaped. In this case, it is convenient to construct the <code>Site</code> using (<code>position_to_site</code>)[@ref], which always takes a position in fractional coordinates of the original lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/System.jl#L97-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.SpinInfo" href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinInfo(atom::Int; S, g=2)</code></pre><p>Characterizes the spin at a given <code>atom</code> index within the crystal unit cell. <code>S</code> is an integer multiple of 1/2 and gives the spin angular momentum in units of Ä§. <code>g</code> is the g-factor or tensor, such that an angular momentum dipole <span>$s$</span> produces a magnetic moment <span>$g s$</span> in units of the Bohr magneton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/SpinInfo.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.StructureFactor-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.StructureFactor</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructureFactor(sys::System; Î”t, nÏ‰, measperiod, apply_g = true, observables = nothing,
                    correlations = nothing, process_trajectory = :none)</code></pre><p><code>StructureFactor</code> is the basic type for calculating <span>$ğ’®(q,Ï‰)$</span> or <span>$ğ’®(q)$</span> data, storing the results, and retrieving intensity information. </p><p>Instead of creating <code>StructureFactor</code> directly, one should call either either <a href="#Sunny.DynamicStructureFactor-Tuple{System}"><code>DynamicStructureFactor</code></a> or <a href="#Sunny.InstantStructureFactor-Tuple{System}"><code>InstantStructureFactor</code></a>.</p><p>Data may be retrieved from a <code>StructureFactor</code> by calling <a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>intensities</code></a>  or <a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>instant_intensities</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/StructureFactors.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}" href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)</code></pre><p>Construct a <code>System</code> of spins for a given <a href="#Sunny.Crystal"><code>Crystal</code></a> symmetry. The <code>latsize</code> parameter determines the number of unit cells in each lattice vector direction. The <code>infos</code> parameter is a list of <a href="#Sunny.SpinInfo"><code>SpinInfo</code></a> objects, which determine the magnitude <span>$S$</span> and <span>$g$</span>-tensor of each spin.</p><p>The three possible options for <code>mode</code> are <code>:SUN</code>, <code>:dipole</code>, and <code>:large_S</code>. The most variationally accurate choice is <code>:SUN</code>, in which each spin-<span>$S$</span> degree of freedom is described as an SU(<em>N</em>) coherent state, where <span>$N = 2S + 1$</span>. Note that an SU(<em>N</em>) coherent state fully describes any local spin state; this description includes expected dipole components <span>$âŸ¨SÌ‚áµ…âŸ©$</span>, quadrupole components <span>$âŸ¨SÌ‚áµ…SÌ‚áµ+SÌ‚áµSÌ‚áµ…âŸ©$</span>, etc.</p><p>The choice <code>:dipole</code> projects the SU(<em>N</em>) dynamics onto the space of pure dipoles. In practice this means that Sunny will simulate Landau-Lifshitz dynamics, but all single-ion anisotropy or biquadratic exchange interactions will be automatically renormalized for maximum accuracy. [IN PROGRESS]</p><p>To disable such renormalization, e.g. to reproduce results collected using the historical large-<span>$S$</span> classical limit, use <code>mode=:large_S</code>. [IN PROGRESS] Modes <code>:SUN</code> or <code>:dipole</code> should be preferred for the development of new models.</p><p>The default units system of (meV, â„«, tesla) can be overridden by with the <code>units</code> parameter; see <a href="#Sunny.Units"><code>Units</code></a>. </p><p>An optional <code>seed</code> may be provided to achieve reproducible random number generation.</p><p>All spins are initially polarized in the <span>$z$</span>-direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/System.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.DynamicStructureFactor-Tuple{System}" href="#Sunny.DynamicStructureFactor-Tuple{System}"><code>Sunny.DynamicStructureFactor</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DynamicStructureFactor(sys::System; Î”t, nÏ‰, Ï‰max, 
    apply_g=true, process_trajectory=:none, observables=nothing, correlations=nothing)</code></pre><p>Creates a <code>StructureFactor</code> for calculating and storing <span>$ğ’®(q,Ï‰)$</span> data. When calculating a dynamic structure factor from classical dynamics, it is necessary to generate spin trajetories which are used to calculate correlations. The initial conditions for these trajectories must be sample spin configurations drawn from the equilibrium distribution at the desired temperature. One such trajectory is calculated immediately when initializing a <code>DynamicStructureFactor</code>, so the spins in the <code>sys</code> must represent a good sample before calling this function. Additional sample trajectories are created and accumulated into the <code>DynamicStructureFactor</code> by calling <a href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>add_sample!</code></a><code>(sf, sys)</code>. The spins in the <code>sys</code> should be set to new sample configurations before each call to <code>add_sample!</code>. This can be achieved, for example, with the <a href="#Sunny.Langevin"><code>Langevin</code></a> dynamics.</p><p>Three keywords are required to specify the dynamics used for the trajectory calculation.</p><ul><li><code>Î”t</code>: The time step used for calculating the trajectory from which dynamic   spin-spin correlations are calculated. The trajectories are calculated with   an <a href="#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a> integrator.</li><li><code>Ï‰max</code>: The maximum energy, <span>$Ï‰$</span>, that will be resolved.</li><li><code>nÏ‰</code>: The number of energy bins to calculated between 0 and <code>Ï‰max</code>.</li></ul><p>Additional keyword options are the following:</p><ul><li><code>apply_g</code>: Determines whether to apply the g-factor when calculating   trajectories.</li><li><code>process_trajectory</code>: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are <code>:none</code> and   <code>:symmetrize</code>. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.</li><li><code>observables</code>: Enables an advanced feature for SU(<em>N</em>) mode, allowing the user to   specify custom observables other than the three components of the dipole. To   use this features, <code>observables</code> must be given an <code>NÃ—NÃ—numops</code> array, where the   final index is used to retrieve each <code>NÃ—N</code> operator.</li><li><code>correlations</code>: Specify which correlation functions are calculated, i.e. which   matrix elements <span>$Î±Î²$</span> of <span>$ğ’®^{Î±Î²}(q,Ï‰)$</span> are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by the x, y, and z dipolar components (1, 2,   and 3 respectively). To retain only the xx and xy correlations, one would   set <code>correlations=[(1,1), (1,2)]</code>. If custom observables (<code>observables</code>) are given,   the indices are ordered in the same manner as the final index of <code>ops</code>.</li></ul><p>The <span>$ğ’®(q,Ï‰)$</span> data can be retrieved by calling <a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>intensities</code></a> or <a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>instant_intensities</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/StructureFactors.jl#L103-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.InstantStructureFactor-Tuple{System}" href="#Sunny.InstantStructureFactor-Tuple{System}"><code>Sunny.InstantStructureFactor</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InstantStructureFactor(sys::System; apply_g=true, process_trajectory=:none,
                        observables=nothing, correlations=nothing)</code></pre><p>Creates a <code>StructureFactor</code> for calculating and storing <span>$ğ’®(q)$</span> data, i.e., spin-spin correlation data calculated at single time steps. An initial sample is generated from the spins in <code>sys</code> when calling <code>InstantStructureFactor</code>, so the spins should represent a good equilibrium sample before this function is called. Additional samples may be generated by calling <a href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>add_sample!</code></a><code>(sf, sys)</code>. The spins in the <code>sys</code> should be resampled before each call to <code>add_sample!</code>.</p><p>The the following optional keywords are available:</p><ul><li><code>apply_g</code>: Determines whether to apply the g-factor when calculating   trajectories.</li><li><code>process_trajectory</code>: Specifies a function that will be applied to the sample   trajectory before correlation analysis. Current options are <code>:none</code> and   <code>:symmetrize</code>. The latter will symmetrize the trajectory in time, which can   be useful for removing Fourier artifacts that arise when calculating the   correlations.</li><li><code>observables</code>: Enables an advanced feature for SU(<em>N</em>) mode, allowing the user to   specify custom observables other than the three components of the dipole. To   use this features, <code>observables</code> must be given an <code>NÃ—NÃ—numops</code> array, where the   final index is used to retrieve each <code>NÃ—N</code> operator.</li><li><code>correlations</code>: Specify which correlation functions are calculated, i.e. which   matrix elements <span>$Î±Î²$</span> of <span>$ğ’®^{Î±Î²}(q,Ï‰)$</span> are calculated and stored.   Specified with a vector of tuples. By default Sunny records all auto- and   cross-correlations generated by the x, y, and z dipolar components (1, 2,   and 3 respectively). To retain only the xx and xy correlations, one would   set <code>correlations=[(1,1), (1,2)]</code>. If custom observables (<code>observables</code>) are given,   the indices are ordered in the same manner as the final index of <code>observables</code>.</li></ul><p><span>$ğ’®(ğª)$</span> data can be retrieved by calling <a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>instant_intensities</code></a>.</p><p>NOTE: It is often advisable to generate a instantaneous structure factor, <span>$ğ’®(ğª)$</span>, from a dynamic structure factor, <span>$ğ’®(ğª,Ï‰)$</span>, by integrating out <span>$Ï‰$</span>, rather than calculating <span>$ğ’®(ğª)$</span> directly from spin-spin correlations at single instances of time. This approach makes it possible to apply a temperature- and <span>$Ï‰$</span>-dependent classical-to-quantum intensity rescaling to the results. This can be done in Sunny by calculating a <code>DynamicStructureFactor</code> and retrieving <span>$ğ’®(ğª)$</span> data with <a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>instant_intensities</code></a>, taking care to set the <code>kT</code> keyword to the appropriate value. <code>instant_intensities</code> will then integrate the <span>$Ï‰$</span> information out after applying intensity corrections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/StructureFactors.jl#L161-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.add_sample!-Tuple{StructureFactor, System}" href="#Sunny.add_sample!-Tuple{StructureFactor, System}"><code>Sunny.add_sample!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_sample!(sf::StructureFactor, sys::System)</code></pre><p><code>add_trajectory</code> uses the spin configuration contained in the <code>System</code> to generate a correlation data and accumulate it into <code>sf</code>. For static structure factors, this involves analyzing the spin-spin correlations of the spin configuration provided. For a dynamic structure factor, a trajectory is calculated using the given spin configuration as an initial condition. The spin-spin correlations are then calculating in time and accumulated into <code>sf</code>. </p><p>This function will change the state of <code>sys</code> when calculating dynamical structure factor data. To preserve the initial state of <code>sys</code>, it must be saved separately prior to calling <code>add_sample!</code>. Alternatively, the initial spin configuration may be copied into a new <code>System</code> and this new <code>System</code> can be passed to <code>add_sample!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/SampleGeneration.jl#L131-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.all_exact_wave_vectors-Tuple{StructureFactor}" href="#Sunny.all_exact_wave_vectors-Tuple{StructureFactor}"><code>Sunny.all_exact_wave_vectors</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_exact_wave_vectors(sf::StructureFactor; bzsize=(1,1,1))</code></pre><p>Returns all wave vectors for which <code>sf</code> contains exact values. <code>bsize</code> specifies the number of Brillouin zones to be included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/SFUtils.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.broaden_energy-Tuple{StructureFactor, Any, Function}" href="#Sunny.broaden_energy-Tuple{StructureFactor, Any, Function}"><code>Sunny.broaden_energy</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">broaden_energy(sf::StructureFactor, vals, kernel::Function; negative_energies=false)</code></pre><p>Performs a real-space convolution along the energy axis of an array of intensities. Assumes the format of the intensities array corresponds to what would be returned by <a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>intensities</code></a>. <code>kernel</code> must be a function that takes two numbers: <code>kernel(Ï‰, Ï‰â‚€)</code>, where <code>Ï‰</code> is a frequency, and <code>Ï‰â‚€</code> is the center frequency of the kernel. Sunny provides <a href="#Sunny.lorentzian-Tuple{Any, Any}"><code>lorentzian</code></a> for the most common use case:</p><pre><code class="nohighlight hljs">newvals = broaden_energy(sf, vals, (Ï‰, Ï‰â‚€) -&gt; lorentzian(Ï‰-Ï‰â‚€, 0.2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/DataRetrieval.jl#L232-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.browser-Tuple{String}" href="#Sunny.browser-Tuple{String}"><code>Sunny.browser</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">browser(html_str; dir)</code></pre><p>Launch a system browser to display the provided HTML string or SunnyViewer. If a directory <code>dir</code> is provided, an HTML file will be written at that location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/SunnyGfx/SunnyGfx.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.connected_path-Tuple{Vector, Any}" href="#Sunny.connected_path-Tuple{Vector, Any}"><code>Sunny.connected_path</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connected_path(qs::Vector, density)</code></pre><p>Takes a list of wave vectors, <code>qs</code>, and builds an expanded list of wave vectors that traces a path through the provided points. Also returned is a list of marker indices corresponding to the intput points. The <code>density</code> parameter controls the frequency of sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/DataRetrieval.jl#L196-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.dmvec-Tuple{Any}" href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dmvec(D)</code></pre><p>Antisymmetric matrix representation of the Dzyaloshinskii-Moriya pseudo-vector,</p><pre><code class="nohighlight hljs">  [  0    D[3] -D[2]
   -D[3]   0    D[1]
    D[2] -D[1]   0  ]</code></pre><p>Useful in the context of <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/PairExchanges.jl#L266-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.enable_dipole_dipole!-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.enable_dipole_dipole!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enable_dipole_dipole!(sys::System)</code></pre><p>Enables long-range dipole-dipole interactions,</p><p class="math-container">\[    -(Î¼â‚€/4Ï€) âˆ‘_{âŸ¨ijâŸ©}  (3 (ğŒ_jâ‹…ğ«Ì‚_{ij})(ğŒ_iâ‹…ğ«Ì‚_{ij}) - ğŒ_iâ‹…ğŒ_j) / |ğ«_{ij}|^3\]</p><p>where the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are <span>$ğŒ_i = Î¼_B g ğ’_i$</span> where <span>$g$</span> is the g-factor or g-tensor, and <span>$ğ’_i$</span> is the spin angular momentum dipole in units of Ä§. The Bohr magneton <span>$Î¼_B$</span> and vacuum permeability <span>$Î¼_0$</span> are physical constants, with numerical values determined by the unit system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/Interactions.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy(sys::System)</code></pre><p>Computes the total system energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/Interactions.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.forces</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forces(Array{Vec3}, sys::System)</code></pre><p>Returns the effective local field (force) at each site, <span>$ğ = -âˆ‚E/âˆ‚ğ¬$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/Interactions.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}" href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.instant_intensities</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instant_intensities(sf::StructureFactor, qs, mode; kwargs...)</code></pre><p>Return <span>$ğ’®(ğª)$</span> intensities at wave vectors <code>qs</code>. The functionality is very similar to <a href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>intensities</code></a>, except the returned array has dimensions identical to <code>qs</code>. If called on a <code>StructureFactor</code> with dynamical information, i.e., <span>$ğ’®(ğª,Ï‰)$</span>, the <span>$Ï‰$</span> information is integrated out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/DataRetrieval.jl#L179-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.intensities-Tuple{StructureFactor, Any, Any}" href="#Sunny.intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.intensities</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensities(sf::StructureFactor, qs, mode; interpolation = nothing,
                kT = nothing, formfactors = nothing, negative_energies = false)</code></pre><p>The basic function for retrieving <span>$ğ’®(ğª,Ï‰)$</span> information from a <code>StructureFactor</code>. Maps an array of wave vectors <code>qs</code> to an array of structure factor intensities, including an additional energy index. The values of <span>$Ï‰$</span> associated with the energy index can be retrieved by calling <a href="#Sunny.Ï‰s-Tuple{StructureFactor}"><code>Ï‰s</code></a>. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.</p><ul><li><code>mode</code>: Should be one of <code>:trace</code>, <code>:perp</code>, or <code>:full</code>. Determines an optional   contraction on the indices <span>$Î±$</span> and <span>$Î²$</span> of <span>$ğ’®^{Î±Î²}(q,Ï‰)$</span>. Setting   <code>trace</code> yields <span>$âˆ‘_Î± ğ’®^{Î±Î±}(q,Ï‰)$</span>. Setting <code>perp</code> will employ a   polarization correction on the traced value. Setting <code>full</code> will return all   elements <span>$ğ’®^{Î±Î²}(ğª,Ï‰)$</span> with contraction.</li><li><code>interpolation</code>: Since <span>$ğ’®(ğª, Ï‰)$</span> is calculated on a finite lattice, data is   only available at discrete wave vectors. By default, Sunny will round a   requested <code>q</code> to the nearest available wave vector. Linear interpolation can   be applied by setting <code>interpolation=:linear</code>.</li><li><code>kT</code>: If a temperature is provided, the intensities will be rescaled by a   temperature- and Ï‰-dependent classical-to-quantum factor. <code>kT</code> should be   specified when making comparisons with spin wave calculations or   experimental data.</li><li><code>formfactors</code>: To apply form factor corrections, provide this keyword with a   vector of <code>FormFactor</code>s, one for each unique site in the unit cell. Sunny   will symmetry propagate the results to all equivalent sites.</li><li><code>negative_energies</code>: If set to <code>true</code>, Sunny will return the periodic   extension of the energy axis. Most users will not want this.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/DataRetrieval.jl#L66-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}" href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_params(lat_vecs::Mat3)</code></pre><p>Compute the lattice parameters <span>$(a, b, c, Î±, Î², Î³)$</span> for the three lattice vectors provided as columns of <code>lat_vecs</code>. The inverse mapping is <a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/LatticeUtils.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lattice_vectors-NTuple{6, Any}" href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_vectors(a, b, c, Î±, Î², Î³)</code></pre><p>Return the lattice vectors, as columns of the <span>$3Ã—3$</span> output matrix, that correspond to the conventional unit cell defined by the lattice constants <span>$(a, b, c)$</span> and the angles <span>$(Î±, Î², Î³)$</span> in degrees. The inverse mapping is <a href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>lattice_params</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/LatticeUtils.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lorentzian-Tuple{Any, Any}" href="#Sunny.lorentzian-Tuple{Any, Any}"><code>Sunny.lorentzian</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lorentzian(x, Î·)</code></pre><p>Returns <span>$Î·^2/(x^2 + Î·^2)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/DataRetrieval.jl#L225-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.plot_spins-Tuple{System}" href="#Sunny.plot_spins-Tuple{System}"><code>Sunny.plot_spins</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_spins(sys::System; linecolor=:grey, arrowcolor=:red, linewidth=0.1,
                            arrowsize=0.3, arrowlength=1.0, kwargs...)</code></pre><p>Plot the spin configuration defined by <code>sys</code>. <code>kwargs</code> are passed to <code>GLMakie.arrows</code>.        </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Plotting.jl#L234-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_anisotropy_as_classical_spins-Tuple{Any}" href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>Sunny.print_anisotropy_as_classical_spins</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_anisotropy_as_classical_spins(p)</code></pre><p>Prints a quantum operator (e.g. linear combination of Stevens operators) as a polynomial of spin expectation values in the classical limit.</p><p>See also <a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>print_anisotropy_as_stevens</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/LocalOperators.jl#L323-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_anisotropy_as_stevens-Tuple{Any}" href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>Sunny.print_anisotropy_as_stevens</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_anisotropy_as_stevens(p; N)</code></pre><p>Prints a quantum operator (e.g. a polynomial of the spin operators <code>ğ’®</code>) as a linear combination of Stevens operators. The parameter <code>N</code> specifies the dimension of the SU(<em>N</em>) representation, corresponding to quantum spin magnitude <span>$S = (N-1)/2$</span>. The special value <code>N = 0</code> indicates the large-<span>$S$</span> classical limit.</p><p>In the output, the symbol <code>X</code> denotes the spin operator magnitude squared. Quantum spin operators <span>$ğ’®$</span> of any finite dimension satisfy <span>$X = |ğ’®|^2 = S (S+1)$</span>. To take the large-<span>$S$</span> limit, however, we keep only leading order powers of <span>$S$</span>, such that <span>$X = S^2$</span>.</p><p>This function can be useful for understanding the conversions performed internally by <a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>set_anisotropy!</code></a>.</p><p>For the inverse mapping, see <a href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>print_anisotropy_as_classical_spins</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/LocalOperators.jl#L337-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_bond-Tuple{Crystal, Bond}" href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)</code></pre><p>Prints symmetry information for bond <code>bond</code>. A symmetry-equivalent reference bond <code>b_ref</code> can optionally be provided to fix the meaning of the coefficients <code>A</code>, <code>B</code>, ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/Printing.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_dominant_wavevectors-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.print_dominant_wavevectors-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.print_dominant_wavevectors</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_dominant_wavevectors(sys::System; nmax=10)</code></pre><p>Prints a list of wavevectors according to their weights in the static structure factor. Coordinates are given in units of reciprocal lattice vectors. These dominant wavevectors may be used as input to <a href="#Sunny.suggest_magnetic_supercell-Tuple{Any, Any}"><code>suggest_magnetic_supercell</code></a>.</p><p>Unlike in <a href="#Sunny.instant_intensities-Tuple{StructureFactor, Any, Any}"><code>instant_intensities</code></a>, here the structure factor weights do not incorporate phase averaging between sublattices. Instead, intensities are calculated for each sublattice independently, and naÃ¯vely summed. This means that wavevectors beyond the first Brillouin zone will be missing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/System.jl#L431-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_site-Tuple{Any, Any}" href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_site(cryst, i; R=I)</code></pre><p>Print symmetry information for the site <code>i</code>, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix <code>R</code> can be provided to define the reference frame for expression of the anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/Printing.jl#L217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_suggested_frame-Tuple{Crystal, Int64}" href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_suggested_frame(cryst, i; digits=4)</code></pre><p>Print a suggested reference frame, as a rotation matrix <code>R</code>, that can be used as input to <code>print_site()</code>. This is useful to simplify the description of allowed anisotropies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/Printing.jl#L198-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_symmetry_table-Tuple{Crystal, Any}" href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_symmetry_table(cryst::Crystal, max_dist)</code></pre><p>Print symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of <code>max_dist</code>. Equivalent to calling <code>print_bond(cryst, b)</code> for every bond <code>b</code> in <code>reference_bonds(cryst, max_dist)</code>, where <code>Bond(i, i, [0,0,0])</code> refers to a single site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/Printing.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.propose_delta-Tuple{Any}" href="#Sunny.propose_delta-Tuple{Any}"><code>Sunny.propose_delta</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_delta(magnitude)</code></pre><p>Generate a proposal function that adds a Gaussian perturbation to the existing spin. The <code>magnitude</code> is typically order one or smaller. For use with <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Samplers.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.propose_flip-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.propose_flip</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_flip</code></pre><p>Function to propose Ising spin flip updates. For use with <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Samplers.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.propose_mix-Tuple{Any, Any}" href="#Sunny.propose_mix-Tuple{Any, Any}"><code>Sunny.propose_mix</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propose_mix(options, weights)</code></pre><p>Generate a proposal function that randomly selects among all <code>options</code>, according to the probability <code>weights</code>. For use with <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">propose_mix([propose_flip, propose_delta(0.2)], [0.5, 0.5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Samplers.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.propose_uniform" href="#Sunny.propose_uniform"><code>Sunny.propose_uniform</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propose_uniform</code></pre><p>Function to propose a uniformly random spin update. For use with <a href="#Sunny.LocalSampler"><code>LocalSampler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Samplers.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.reference_bonds-Tuple{Crystal, Float64}" href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reference_bonds(cryst::Crystal, max_dist)</code></pre><p>Returns a full list of bonds, one for each symmetry equivalence class, up to distance <code>max_dist</code>. The reference bond <code>b</code> for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in <code>basis_for_symmetry_allowed_couplings(cryst, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/SymmetryAnalysis.jl#L218-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.repeat_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.repeat_periodically</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat_periodically(sys::System{N}, counts) where N</code></pre><p>Creates a <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> identical to <code>sys</code> but repeated a given number of times in each dimension, specified by the tuple <code>counts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/System.jl#L415-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.reshape_geometry</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reshape_geometry(sys::System, A)</code></pre><p>Maps an existing <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> to a new one that has the shape and periodicity of a requested supercell. The columns of the <span>$3Ã—3$</span> integer matrix <code>A</code> represent the supercell lattice vectors measured in units of the original crystal lattice vectors.</p><p>The crystal unit cell may also need to be reshaped to achieve the desired periodicity of the requested supercell. If this is the case, the returned <code>System</code> object will be missing symmetry information. Consequently, certain operations will be unavailable for this system, e.g., setting interactions by symmetry propagation. In practice, one can set all interactions using the original system, and then reshape as a final step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/System.jl#L261-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.resize_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.resize_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.resize_periodically</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize_periodically(sys::System{N}, latsize) where N</code></pre><p>Creates a <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> identical to <code>sys</code> but enlarged to a given number of unit cells in each lattice vector direction.</p><p>An error will be thrown if <code>sys</code> is incommensurate with <code>latvecs</code>. Use <a href="#Sunny.reshape_geometry-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>reshape_geometry</code></a> instead to reduce the volume, or to perform an incommensurate reshaping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/System.jl#L392-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N" href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>Sunny.set_anisotropy!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_anisotropy!(sys::System, op, i::Int)</code></pre><p>Set the single-ion anisotropy for the <code>i</code>th atom of every unit cell, as well as all symmetry-equivalent atoms. The parameter <code>op</code> may be a polynomial in symbolic spin operators <code>ğ’®[Î±]</code>, or a linear combination of symbolic Stevens operators <code>ğ’ª[k,q]</code>.</p><p>The characters <code>ğ’®</code> and <code>ğ’ª</code> can be copy-pasted from this help message, or typed at a Julia terminal using <code>\scrS</code> or <code>\scrO</code> followed by tab-autocomplete.</p><p>For systems restricted to dipoles, the anisotropy operators interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(<em>N</em>) mode.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># An easy axis anisotropy in the z-direction
set_anisotropy!(sys, -D*ğ’®[3]^3, i)

# The unique quartic single-ion anisotropy for a site with cubic point group
# symmetry
set_anisotropy!(sys, ğ’ª[4,0] + 5ğ’ª[4,4], i)

# An equivalent expression of this quartic anisotropy, up to a constant shift
set_anisotropy!(sys, 20*(ğ’®[1]^4 + ğ’®[2]^4 + ğ’®[3]^4), i)</code></pre><p>See also <a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>print_anisotropy_as_stevens</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/SingleIonAnisotropies.jl#L30-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_anisotropy_at!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N" href="#Sunny.set_anisotropy_at!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N"><code>Sunny.set_anisotropy_at!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_anisotropy_at!(sys::System, op, idx::Site)</code></pre><p>Sets the single-ion anisotropy operator <code>op</code> for a single <a href="#Sunny.Site"><code>Site</code></a>, ignoring crystal symmetry.  The system must support inhomogeneous interactions via <a href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>See also <a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>set_anisotropy!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/SingleIonAnisotropies.jl#L86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N" href="#Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_biquadratic!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_biquadratic!(sys::System, J, bond::Bond)</code></pre><p>Sets a scalar biquadratic interaction along <code>bond</code>, yielding a pairwise energy <span>$J (ğ’_iâ‹…ğ’_j)Â²$</span>. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous biquadratic exchange interactions on these bonds will be overwritten.</p><p>For systems restricted to dipoles, the biquadratic interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(<em>N</em>) mode. This renormalization introduces also a correction to the quadratic part of the exchange.</p><p>See also <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/PairExchanges.jl#L32-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_biquadratic_at!-Union{Tuple{N}, Tuple{System{N}, Any, Bond, Any}} where N" href="#Sunny.set_biquadratic_at!-Union{Tuple{N}, Tuple{System{N}, Any, Bond, Any}} where N"><code>Sunny.set_biquadratic_at!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_biquadratic_at!(sys::System, J, bond::Bond, idx::Site)</code></pre><p>Sets the scalar biquadratic interaction along the provided <a href="#Sunny.Bond"><code>Bond</code></a> for a single <a href="#Sunny.Site"><code>Site</code></a>, ignoring crystal symmetry. The system must support inhomogeneous interactions via <a href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>Note that <code>bond</code> is always defined with respect to the original crystal, whereas <code>idx</code> is an index into the current <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>, which may have been reshaped. The atom index <code>bond.i</code> must be consistent with the system sublattice index <code>idx[4]</code>. </p><p>See also <a href="#Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_biquadratic!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/PairExchanges.jl#L192-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N" href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange!(sys::System, J, bond::Bond)</code></pre><p>Sets a 3Ã—3 spin-exchange matrix <code>J</code> along <code>bond</code>, yielding a pairwise interaction energy <span>$ğ’_iâ‹…J ğ’_j$</span>. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells.</p><p>Scalar <code>J</code> implies a pure Heisenberg exchange.</p><p>As a convenience, <code>dmvec(D)</code> can be used to construct the antisymmetric part of the exchange, where <code>D</code> is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be <span>$ğƒâ‹…(ğ’_iÃ—ğ’_j)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Sunny, LinearAlgebra

# An explicit exchange matrix
J1 = [2 3 0;
     -3 2 0;
      0 0 2]
set_exchange!(sys, J1, bond)

# An equivalent Heisenberg + DM exchange 
J2 = 2*I + dmvec([0,0,3])
set_exchange!(sys, J2, bond)</code></pre><p>See also <a href="#Sunny.set_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_biquadratic!</code></a>, <a href="#Sunny.dmvec-Tuple{Any}"><code>dmvec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/PairExchanges.jl#L88-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Bond, Any}} where N" href="#Sunny.set_exchange_at!-Union{Tuple{N}, Tuple{System{N}, Any, Bond, Any}} where N"><code>Sunny.set_exchange_at!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange_at!(sys::System, J, bond::Bond, idx::Site)</code></pre><p>Sets the exchange interaction along the provided <a href="#Sunny.Bond"><code>Bond</code></a> for a single <a href="#Sunny.Site"><code>Site</code></a>, ignoring crystal symmetry. The system must support inhomogeneous interactions via <a href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>to_inhomogeneous</code></a>.</p><p>Note that <code>bond</code> is always defined with respect to the original crystal, whereas <code>idx</code> is an index into the current <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a>, which may have been reshaped. The atom index <code>bond.i</code> must be consistent with the system sublattice index <code>idx[4]</code>. </p><p>See also <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/PairExchanges.jl#L224-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_external_field!-Tuple{System, Any}" href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field!(sys::System, B::Vec3)</code></pre><p>Sets the external field <code>B</code> that couples to all spins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/Interactions.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_external_field_at!-Tuple{System, Any, Any}" href="#Sunny.set_external_field_at!-Tuple{System, Any, Any}"><code>Sunny.set_external_field_at!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field_at!(sys::System, B::Vec3, idx::Site)</code></pre><p>Sets a Zeeman coupling between a field <code>B</code> and a single spin. <a href="#Sunny.Site"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/Interactions.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N" href="#Sunny.set_vacancy_at!-Union{Tuple{N}, Tuple{System{N}, Any}} where N"><code>Sunny.set_vacancy_at!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_vacancy_at!(sys::System, idx::Site)</code></pre><p>Make a single site nonmagnetic. <a href="#Sunny.Site"><code>Site</code></a> includes a unit cell and a sublattice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/Interactions.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.spherical_shell-Tuple{StructureFactor, Any, Any}" href="#Sunny.spherical_shell-Tuple{StructureFactor, Any, Any}"><code>Sunny.spherical_shell</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spherical_shell(sf::StructureFactor, radius, density)</code></pre><p>Returns a set of wave vectors lying on a sphere of specified radius, where <code>radius</code> is given in <span>$Ã…^{-1}$</span>. <code>density</code> controls how many points to select per <span>$Ã…^{-2}$</span>. </p><p>The points are generated by mapping a Fibonacci lattice onto a sphere. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/PowderAveraging.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.step!-Tuple{System{0}, Langevin}" href="#Sunny.step!-Tuple{System{0}, Langevin}"><code>Sunny.step!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step!(sys::System, integrator)</code></pre><p>Advance the spin dynamics one integration time-step. The <code>integrator</code> may be of type <a href="#Sunny.Langevin"><code>Langevin</code></a> or <a href="#Sunny.ImplicitMidpoint"><code>ImplicitMidpoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Integrators.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N" href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcrystal(cryst, types) :: Crystal</code></pre><p>Filters sublattices of a <code>Crystal</code> by atom <code>types</code>, keeping the space group unchanged.</p><pre><code class="nohighlight hljs">subcrystal(cryst, classes) :: Crystal</code></pre><p>Filters sublattices of <code>Crystal</code> by equivalence <code>classes</code>, keeping the space group unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/Symmetry/Crystal.jl#L448-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.suggest_magnetic_supercell-Tuple{Any, Any}" href="#Sunny.suggest_magnetic_supercell-Tuple{Any, Any}"><code>Sunny.suggest_magnetic_supercell</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">suggest_magnetic_supercell(qs, latsize)</code></pre><p>Suggests a magnetic supercell, in units of the crystal lattice vectors, that is consistent with periodicity of the wavevectors in <code>qs</code>. An upper bound for the supercell is given by <code>latsize</code>, which is measured in units of lattice vectors, and must be commensurate with the wavevectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/System.jl#L487-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.to_inhomogeneous-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.to_inhomogeneous</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_inhomogeneous(sys::System)</code></pre><p>Returns a copy of the system that allows for inhomogeneous interactions, which can be set using (<code>set_anisotropy_at!</code>)[@ref], (<code>set_exchange_at!</code>)[@ref], (<code>set_biquadratic_at!</code>)[@ref], and (<code>set_vacancy_at!</code>)[@ref].</p><p>Inhomogeneous systems do not support symmetry-propagation of interactions or system reshaping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/System/Interactions.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.view_crystal-Tuple{Crystal, Real}" href="#Sunny.view_crystal-Tuple{Crystal, Real}"><code>Sunny.view_crystal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_crystal(crystal::Crystal, max_dist::Real)</code></pre><p>Create and show crystal viewer in a VSCode or Jupyter notebook environment. The result can also be displayed using <code>browser()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/SunnyGfx/CrystalViewer.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Ï‰s-Tuple{StructureFactor}" href="#Sunny.Ï‰s-Tuple{StructureFactor}"><code>Sunny.Ï‰s</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ï‰s(sf::StructureFactor; negative_energies=false)</code></pre><p>Return the Ï‰ values for the energy index of a <code>StructureFactor</code>. By default, only returns values for non-negative energies, which corresponds to the default output of <code>intensities</code>. Set <code>negative_energies</code> to true to retrieve all Ï‰ values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/c97afc67b98a68212c8465548fc2377c8e5dccba/src/StructureFactors/SFUtils.jl#L20-L27">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>To reduce package load times, certain plotting functions are only available when the user explicitly executes &quot;<code>using GLMakie</code>&quot;.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/powder_averaging/">Â« Powder Averaging</a><a class="docs-footer-nextpage" href="../structure-factor/">Structure Factor Calculations Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 13 February 2023 18:33">Monday 13 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
