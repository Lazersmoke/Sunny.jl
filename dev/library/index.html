<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library API ¬∑ Sunny documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Sunny documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Sunny documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../quick-start/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>Library API</a><ul class="internal"><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../structure-factor/">Structure Factor Calculations</a></li><li><a class="tocitem" href="../versions/">Version History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SunnySuite/Sunny.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-API"><a class="docs-heading-anchor" href="#Library-API">Library API</a><a id="Library-API-1"></a><a class="docs-heading-anchor-permalink" href="#Library-API" title="Permalink"></a></h1><p>This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter <code>?</code> at the Julia command prompt).</p><ul><li><a href="#Sunny.Units"><code>Sunny.Units</code></a></li><li><a href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a></li><li><a href="#Sunny.ùí™"><code>Sunny.ùí™</code></a></li><li><a href="#Sunny.ùíÆ"><code>Sunny.ùíÆ</code></a></li><li><a href="#Sunny.BinnedArray"><code>Sunny.BinnedArray</code></a></li><li><a href="#Sunny.Bond"><code>Sunny.Bond</code></a></li><li><a href="#Sunny.Crystal"><code>Sunny.Crystal</code></a></li><li><a href="#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}"><code>Sunny.FormFactor</code></a></li><li><a href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a></li><li><a href="#Sunny.IsingSampler"><code>Sunny.IsingSampler</code></a></li><li><a href="#Sunny.LangevinHeunP"><code>Sunny.LangevinHeunP</code></a></li><li><a href="#Sunny.LangevinSampler"><code>Sunny.LangevinSampler</code></a></li><li><a href="#Sunny.MetropolisSampler"><code>Sunny.MetropolisSampler</code></a></li><li><a href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a></li><li><a href="#Sunny.StructureFactor-Tuple{System}"><code>Sunny.StructureFactor</code></a></li><li><a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a></li><li><a href="#Sunny.WangLandau"><code>Sunny.WangLandau</code></a></li><li><a href="#Sunny.add_trajectory!-Tuple{StructureFactor, System}"><code>Sunny.add_trajectory!</code></a></li><li><a href="#Sunny.all_symmetry_related_anisotropies-Tuple{Crystal, Int64, Any}"><code>Sunny.all_symmetry_related_anisotropies</code></a></li><li><a href="#Sunny.all_symmetry_related_bonds-Tuple{Crystal, Bond}"><code>Sunny.all_symmetry_related_bonds</code></a></li><li><a href="#Sunny.all_symmetry_related_bonds_for_atom-Tuple{Crystal, Int64, Bond}"><code>Sunny.all_symmetry_related_bonds_for_atom</code></a></li><li><a href="#Sunny.all_symmetry_related_couplings-Tuple{Crystal, Bond, Any}"><code>Sunny.all_symmetry_related_couplings</code></a></li><li><a href="#Sunny.all_symmetry_related_couplings_for_atom-Tuple{Crystal, Int64, Bond, Any}"><code>Sunny.all_symmetry_related_couplings_for_atom</code></a></li><li><a href="#Sunny.anneal!-Union{Tuple{S}, Tuple{S, Any, Any}} where S&lt;:Sunny.AbstractSampler"><code>Sunny.anneal!</code></a></li><li><a href="#Sunny.browser-Tuple{String}"><code>Sunny.browser</code></a></li><li><a href="#Sunny.calculate_structure_factor-Tuple{System, Sunny.AbstractSampler}"><code>Sunny.calculate_structure_factor</code></a></li><li><a href="#Sunny.cell_type-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.cell_type</code></a></li><li><a href="#Sunny.cell_volume-Tuple{Crystal}"><code>Sunny.cell_volume</code></a></li><li><a href="#Sunny.connected_path-Tuple{Vector, Any}"><code>Sunny.connected_path</code></a></li><li><a href="#Sunny.coordination_number-Tuple{Crystal, Int64, Bond}"><code>Sunny.coordination_number</code></a></li><li><a href="#Sunny.displacement-Tuple{Crystal, Sunny.BondRaw}"><code>Sunny.displacement</code></a></li><li><a href="#Sunny.distance-Tuple{Crystal, Sunny.BondRaw}"><code>Sunny.distance</code></a></li><li><a href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a></li><li><a href="#Sunny.enable_dipole_dipole!-Tuple{System}"><code>Sunny.enable_dipole_dipole!</code></a></li><li><a href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a></li><li><a href="#Sunny.extend_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.extend_periodically</code></a></li><li><a href="#Sunny.filter_visited-Union{Tuple{BinnedArray{K, V}}, Tuple{V}, Tuple{K}} where {K, V}"><code>Sunny.filter_visited</code></a></li><li><a href="#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.forces</code></a></li><li><a href="#Sunny.get_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.get_intensities</code></a></li><li><a href="#Sunny.get_static_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.get_static_intensities</code></a></li><li><a href="#Sunny.get_temp-Tuple{MetropolisSampler}"><code>Sunny.get_temp</code></a></li><li><a href="#Sunny.init_bounded!-Tuple{WangLandau}"><code>Sunny.init_bounded!</code></a></li><li><a href="#Sunny.intensity_grid-Tuple{StructureFactor, Any}"><code>Sunny.intensity_grid</code></a></li><li><a href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a></li><li><a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a></li><li><a href="#Sunny.nbasis-Tuple{Crystal}"><code>Sunny.nbasis</code></a></li><li><a href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>Sunny.print_anisotropy_as_classical_spins</code></a></li><li><a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>Sunny.print_anisotropy_as_stevens</code></a></li><li><a href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a></li><li><a href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a></li><li><a href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a></li><li><a href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a></li><li><a href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a></li><li><a href="#Sunny.reset!-Union{Tuple{BinnedArray{K, V}}, Tuple{V}, Tuple{K}} where {K, V}"><code>Sunny.reset!</code></a></li><li><a href="#Sunny.run!-Tuple{WangLandau}"><code>Sunny.run!</code></a></li><li><a href="#Sunny.sample!-Union{Tuple{MetropolisSampler{N}}, Tuple{N}} where N"><code>Sunny.sample!</code></a></li><li><a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>Sunny.set_anisotropy!</code></a></li><li><a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a></li><li><a href="#Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N"><code>Sunny.set_exchange_with_biquadratic!</code></a></li><li><a href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a></li><li><a href="#Sunny.set_local_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N"><code>Sunny.set_local_anisotropy!</code></a></li><li><a href="#Sunny.set_local_external_field!-Tuple{System, Any, Any}"><code>Sunny.set_local_external_field!</code></a></li><li><a href="#Sunny.set_temp!-Tuple{MetropolisSampler, Any}"><code>Sunny.set_temp!</code></a></li><li><a href="#Sunny.step!-Tuple{System{0}, LangevinHeunP}"><code>Sunny.step!</code></a></li><li><a href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a></li><li><a href="#Sunny.thermalize!-Union{Tuple{S}, Tuple{S, Int64}} where S&lt;:Sunny.AbstractSampler"><code>Sunny.thermalize!</code></a></li><li><a href="#Sunny.view_crystal-Tuple{Crystal, Real}"><code>Sunny.view_crystal</code></a></li><li><a href="#Sunny.œâvals-Tuple{StructureFactor}"><code>Sunny.œâvals</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Sunny.Units" href="#Sunny.Units"><code>Sunny.Units</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Units.meV
Units.theory</code></pre><p>The unit system is implicitly determined by the definition of two physical constants: the vacuum permeability <span>$Œº‚ÇÄ$</span> and the Bohr magneton <span>$Œº_B$</span>. Temperatures are effectively measured in units of energy (<span>$k_B = 1$</span>) and time is effectively measured in units of inverse energy (<span>$ƒß = 1$</span>). The default unit system, <code>Units.meV</code>, employs (meV, ‚Ñ´, tesla). Select alternatively <code>Units.theory</code> for a units system defined so that <span>$Œº‚ÇÄ = Œº_B = 1$</span>.</p><p>See also <a href="#Sunny.meV_per_K"><code>meV_per_K</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Units.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.meV_per_K" href="#Sunny.meV_per_K"><code>Sunny.meV_per_K</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">meV_per_K = 0.086173332621451774</code></pre><p>A physical constant. Useful for converting kelvin into the default energy units, meV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Units.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ùí™" href="#Sunny.ùí™"><code>Sunny.ùí™</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ùí™[k,q]</code></pre><p>Abstract symbols for the Stevens operators. Linear combinations of these can be used to specify the single-ion anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/LocalOperators.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ùíÆ" href="#Sunny.ùíÆ"><code>Sunny.ùíÆ</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ùíÆ[1], ùíÆ[2], ùíÆ[3]</code></pre><p>Abstract symbols for the spin operators. Polynomials of these can be used to specify the single-ion anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/LocalOperators.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.BinnedArray" href="#Sunny.BinnedArray"><code>Sunny.BinnedArray</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct BinnedArray{K, V}</code></pre><p>Adaptive array that bins data. Can be used as a histogram. Just 1D now, but could use raveled index if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/WangLandau/BinnedArray.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Bond" href="#Sunny.Bond"><code>Sunny.Bond</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bond(i, j, n)</code></pre><p>Represents a bond between atom indices <code>i</code> and <code>j</code>. <code>n</code> is a vector of three integers specifying unit cell displacement in terms of lattice vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Bond.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.Crystal" href="#Sunny.Crystal"><code>Sunny.Crystal</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:</p><pre><code class="nohighlight hljs">Crystal(filename; symprec=1e-5)</code></pre><p>Reads the crystal from a <code>.cif</code> file located at the path <code>filename</code>.  The optional parameter <code>symprec</code> controls the precision tolerance for spacegroup symmetries.</p><pre><code class="nohighlight hljs">Crystal(lat_vecs, positions; types=nothing, symprec=1e-5)</code></pre><p>Constructs a crystal from the complete list of atom positions <code>positions</code>, with coordinates (between 0 and 1) in units of lattice vectors <code>lat_vecs</code>. Spacegroup symmetry information is automatically inferred. The optional parameter <code>types</code> is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.</p><pre><code class="nohighlight hljs">Crystal(lat_vecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)</code></pre><p>Builds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional <code>setting</code> string will disambiguate between unit cell conventions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Read a Crystal from a .cif file
Crystal(&quot;filename.cif&quot;)

# Build an FCC crystal using the primitive unit cell. The spacegroup number
# 225 is inferred.
lat_vecs = [1 1 0;
            1 0 1;
            0 1 1] / 2
positions = [[0, 0, 0]]
Crystal(lat_vecs, positions)

# Build a CsCl crystal (two cubic sublattices). By providing distinct type
# strings, the spacegroup number 221 is inferred.
lat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[0,0,0], [0.5,0.5,0.5]]
types = [&quot;Na&quot;, &quot;Cl&quot;]
cryst = Crystal(lat_vecs, positions; types)

# Build a diamond cubic crystal from its spacegroup number 227. This
# spacegroup has two possible settings (&quot;1&quot; or &quot;2&quot;), which determine an
# overall unit cell translation.
lat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)
positions = [[1, 1, 1] / 4]
cryst = Crystal(lat_vecs, positions, 227; setting=&quot;1&quot;)</code></pre><p>See also <a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Crystal.jl#L8-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}" href="#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}"><code>Sunny.FormFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FormFactor(atom::Int64, elem::String; g_lande=nothing)</code></pre><p>Basic type for specifying form factor parameters. Must be provided a site within the unit cell (<code>atom</code>) and a string specifying the element name. This used when calling <a href="#Sunny.get_intensities-Tuple{StructureFactor, Any, Any}"><code>get_intensities</code></a>, which requires a list of <code>FormFactors</code>s.</p><p>A list of supported element names is available at:</p><p>https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html</p><p>The Land√© g-factor may also be specified. </p><p>In more detail, the data stored in a <code>FormFactor</code> will be used to compute the form factor for each momentum space magnitude <code>|k|</code>, measured in inverse angstroms. The result is dependent on the magnetic ion species. By default, a first order form factor <span>$f$</span> is returned. If the keyword <code>g_lande</code> is given a numerical value, then a second order form factor <span>$F$</span> is returned.</p><p>It is traditional to define the form factors using a sum of Gaussian broadening functions in the scalar variable <span>$s = |k|/4œÄ$</span>, where <span>$|k|$</span> can be interpreted as the magnitude of momentum transfer.</p><p>The Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors, defines the approximation</p><p><span>$\langle j_l(s) \rangle = A e^{-as^2} + B e^{-bs^2} + Ce^{-cs^2} + D,$</span></p><p>where coefficients <span>$A, B, C, D, a, b, c$</span> are obtained from semi-empirical fits, depending on the orbital angular momentum index <span>$l = 0, 2$</span>. For transition metals, the form-factors are calculated using the Hartree-Fock method. For rare-earth metals and ions, Dirac-Fock form is used for the calculations.</p><p>A first approximation to the magnetic form factor is</p><p><span>$f(s) = \langle j_0(s) \rangle$</span></p><p>A second order correction is given by</p><p><span>$F(s) = \frac{2-g}{g} \langle j_2(s) \rangle s^2 + f(s)$</span>, where <span>$g$</span> is the Land√© g-factor.  </p><p>Digital tables are available at:</p><ul><li>https://www.ill.eu/sites/ccsl/ffacts/ffachtml.html</li></ul><p>Additional references are:</p><ul><li>Marshall W and Lovesey S W, Theory of thermal neutron scattering Chapter 6 Oxford University Press (1971)</li><li>Clementi E and Roetti C,  Atomic Data and Nuclear Data Tables, 14 pp 177-478 (1974)</li><li>Freeman A J and Descleaux J P, J. Magn. Mag. Mater., 12 pp 11-21 (1979)</li><li>Descleaux J P and Freeman A J, J. Magn. Mag. Mater., 8 pp 119-129 (1978) </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/StructureFactors/FormFactor.jl#L12-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.ImplicitMidpoint" href="#Sunny.ImplicitMidpoint"><code>Sunny.ImplicitMidpoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImplicitMidpoint(Œît::Float64; atol=1e-12) where N</code></pre><p>Energy-conserving integrator for simulating dynamics without damping or noise. Use with the <code>step!</code> function to evolve a <code>System</code> forward by a time step of <code>Œît</code>:</p><p>step!(sys::System, integrator::ImplicitMidpoint)</p><p>The above function will use the spherical midpoint integration scheme for dipole systems and the Schrodinger midpoint integration scheme for SU(N) spin systems. Both integration schemes are symplectic (energy-conserving) and are appropriate for simulating dissipationless dynamics over long periods of time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Integrators.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.IsingSampler" href="#Sunny.IsingSampler"><code>Sunny.IsingSampler</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsingSampler(sys::System, kT::Float64, nsweeps::Int)</code></pre><p>A sampler which performs the standard Metropolis Monte Carlo algorithm to sample a <code>System</code> at the requested temperature.</p><p>This version differs from <code>MetropolisSampler</code> in that each single-spin update only attempts to completely flip the spin. One call to <code>sample!</code> will attempt to flip each spin <code>nsweeps</code> times.</p><p>Before constructing, be sure that your <code>System</code> is initialized so that each spin points along its &quot;Ising-like&quot; axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Samplers.jl#L120-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.LangevinHeunP" href="#Sunny.LangevinHeunP"><code>Sunny.LangevinHeunP</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LangevinHeunP(kT::Float64, Œª::Float64, Œît::Float64)</code></pre><p>Projected Heun integration scheme with noise and damping. Use with the <code>step!</code> function to evolve a <code>System</code> forward by a time step of <code>Œît</code>:</p><p>step!(sys::System, integrator::LangevinHeunP)</p><p>If <code>kT &gt; 0</code>, this will simulate dynamics in the presence of a thermal bath. <code>Œª</code> is an empirical parameter that determines the strength of coupling to the thermal bath and sets a time scale for decorrelation, <code>1/Œª</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Integrators.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.LangevinSampler" href="#Sunny.LangevinSampler"><code>Sunny.LangevinSampler</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LangevinSampler(integrator::LangevinHeunP, nsteps::Int)</code></pre><p>Creates a sampler from a Langevin integrator. <code>nsteps</code> determines how many times <code>step!</code> is called using the integrator. <code>nsteps</code> should be selected large enough to ensure that the state of the System after integration is decorrelated with respect to its initial state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Samplers.jl#L69-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.MetropolisSampler" href="#Sunny.MetropolisSampler"><code>Sunny.MetropolisSampler</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MetropolisSampler(sys::System, kT::Float64, nsweeps::Int)</code></pre><p>A sampler which performs the standard Metropolis Monte Carlo algorithm to sample  a <code>System</code> at the requested temperature.</p><p>Each single-spin update attempts to completely randomize the spin. One call to  <code>sample!</code> will attempt to flip each spin <code>nsweeps</code> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Samplers.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.SpinInfo" href="#Sunny.SpinInfo"><code>Sunny.SpinInfo</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpinInfo(atom::Int; S, g=2)</code></pre><p>Characterizes the spin at a given <code>atom</code> index within the crystal unit cell. <code>S</code> is an integer multiple of 1/2 and gives the spin angular momentum in units of ƒß. <code>g</code> is the g-factor or tensor, such that an angular momentum dipole <span>$s$</span> produces a magnetic moment <span>$g s$</span> in units of the Bohr magneton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/SpinInfo.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.StructureFactor-Tuple{System}" href="#Sunny.StructureFactor-Tuple{System}"><code>Sunny.StructureFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructureFactor(sys::System; Œît = 0.1, nœâ = 1, œâmax = nothing,
                    apply_g = true, ops = nothing, matrix_elems = nothing)</code></pre><p><code>StructureFactor</code> is the basic type for calculating <span>$ùíÆ^{Œ±Œ≤}(q,œâ)$</span>, storing the results, and retrieving intensity information. </p><p>Most users should use <a href="#Sunny.calculate_structure_factor-Tuple{System, Sunny.AbstractSampler}"><code>calculate_structure_factor</code></a> to generate a structure factor. However, one may also directly create a structure factor by providing a <code>System</code> to <code>StructureFactor</code>. Then, to manually generate a sample, the user must ensure that the spins of their system are drawn from an appropriate equilibrium distribution and call <a href="#Sunny.add_trajectory!-Tuple{StructureFactor, System}"><code>add_trajectory!</code></a> function. This process may be repeated as necessary to generate a sufficient statistics. </p><p>The keywords specify all the parameters used in subsequent calculations and must be determined at the time that the <code>StructureFactor</code> is initiated. Specifically:</p><ul><li><code>Œît</code>: Sets the step size of the integrator used to calculate trajectories.</li><li><code>œâmax</code>: Determines the maximum resolved energy.</li><li><code>nœâ</code>: Determines how many energy bins to resolve between 0 and <code>œâmax</code>. If set   to 1, Sunny will calculate a static structure factor.</li><li><code>apply_g</code>: Determines whether to apply the g-factor when calculating   trajectories.</li><li><code>ops</code>: Enables an advanced feature for SU(<em>N</em>) mode, allowing the user to   specify custom observables other than the three components of the dipole. To   use this features, <code>ops</code> must be given an <code>N√óN√ónumops</code> array, where the   final index is used to retrieve each <code>N√óN</code> operator.</li><li><code>matrix_elems</code>: Allows the user to specify which correlation functions are   calculated. This is specified with a vector of tuples. By default Sunny   records all auto- and cross-correlations generated by the x, y, and z   dipolar components. To retain only the xx and xy correlations, one would set   <code>matrix_elems=[(1,1), (1,2)]</code>.</li><li><code>process_trajectory</code>: Specify any preprocessing that should be applied to a   recorded trajectory before calculating correlations. By default, no   processing is applied. Options are <code>:symmetrize</code>, which symmetrizes the   trajectory, and <code>:subtract_mean</code>, which subtracts the mean value. Both   options are useful for eliminating Fourier artifacts that frequently appear   when simulating gapless, or nearly gapless, Hamiltonians.</li></ul><p>If you wish to calculate a dynamical structure factor, the keyword <code>nœâ</code> must set to an integer greater than 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/StructureFactors/StructureFactors.jl#L25-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}" href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>Sunny.System</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)</code></pre><p>Construct a <code>System</code> of spins for a given <code>crystal</code> symmetry. The <code>latsize</code> parameter determines the number of unit cells in each lattice vector direction. The <code>infos</code> parameter is a list of <a href="#Sunny.SpinInfo"><code>SpinInfo</code></a> objects, which determine the magnitude <span>$S$</span> and <span>$g$</span>-tensor of each spin.</p><p>The three possible options for <code>mode</code> are <code>:dipole</code>, <code>:SUN</code>, and <code>:projected</code>. The choice <code>:dipole</code> restricts the description of a spin to its angular momentum dipole. The choice <code>:SUN</code> will expand the description of a spin to a full SU(<em>N</em>) coherent state, where <span>$N = 2S + 1$</span>. This approach captures more quantum mechanical degrees of freedom, e.g., the dynamics of quadrupolar fluctuations <span>$‚ü®SÃÇ·µÖSÃÇ·µù+SÃÇ·µùSÃÇ·µÖ‚ü©$</span>. Finally, the choice <code>:projected</code> produces the SU(<em>N</em>) dynamics but projected to the space of dipoles. In practice, the distinction between <code>:projected</code> and <code>:dipoles</code> is that the former will automatically apply appropriate renormalizations to the single-ion anisotropy and biquadratic exchange interactions for maximum accuracy.</p><p>The default units system of (meV, ‚Ñ´, tesla) can be overridden by with the <code>units</code> parameter; see <a href="#Sunny.Units"><code>Units</code></a>. </p><p>All spins are initially polarized in the <span>$z$</span>-direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/System.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.WangLandau" href="#Sunny.WangLandau"><code>Sunny.WangLandau</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct WangLandau{F&lt;:Function}</code></pre><p>Wang-Landau sampler. All parameters have default values that can be overwritten, but a System must be passed during construction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/WangLandau/WangLandau.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.add_trajectory!-Tuple{StructureFactor, System}" href="#Sunny.add_trajectory!-Tuple{StructureFactor, System}"><code>Sunny.add_trajectory!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_trajectory!(sf::StructureFactor, sys::System)</code></pre><p>When given a <code>StructureFactor</code> and a <code>System</code>, <code>add_trajectory</code> will use the spin state contained in the <code>System</code> as the initial condition for a dynamical trajectory. The correlations generated by the trajectory are calculated and accumulated into the <code>StructureFactor</code>. All trajectory parameters are specified in the <a href="#Sunny.StructureFactor-Tuple{System}"><code>StructureFactor</code></a>.</p><p>Note that this function will <em>not</em> change the spin state in <code>sys</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/StructureFactors/Trajectories.jl#L135-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.all_symmetry_related_anisotropies-Tuple{Crystal, Int64, Any}" href="#Sunny.all_symmetry_related_anisotropies-Tuple{Crystal, Int64, Any}"><code>Sunny.all_symmetry_related_anisotropies</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_symmetry_related_anisotropies(cryst, i_ref, Œõ_ref)</code></pre><p>Return two lists. The first list contains all atoms <code>i</code> that are symmetry equivalent to <code>i_ref</code>. The second list contains the appropriately transformed anisotropy matrices <code>Œõ</code> for each site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Anisotropy.jl#L373-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.all_symmetry_related_bonds-Tuple{Crystal, Bond}" href="#Sunny.all_symmetry_related_bonds-Tuple{Crystal, Bond}"><code>Sunny.all_symmetry_related_bonds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_symmetry_related_bonds(cryst::Crystal, b::Bond)</code></pre><p>Returns a list of all bonds that are symmetry-equivalent to bond <code>b</code> or its reverse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/SymmetryAnalysis.jl#L244-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.all_symmetry_related_bonds_for_atom-Tuple{Crystal, Int64, Bond}" href="#Sunny.all_symmetry_related_bonds_for_atom-Tuple{Crystal, Int64, Bond}"><code>Sunny.all_symmetry_related_bonds_for_atom</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_symmetry_related_bonds_for_atom(cryst::Crystal, i::Int, b::Bond)</code></pre><p>Returns a list of all bonds that start at atom <code>i</code>, and that are symmetry equivalent to bond <code>b</code> or its reverse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/SymmetryAnalysis.jl#L227-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.all_symmetry_related_couplings-Tuple{Crystal, Bond, Any}" href="#Sunny.all_symmetry_related_couplings-Tuple{Crystal, Bond, Any}"><code>Sunny.all_symmetry_related_couplings</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_symmetry_related_couplings(cryst::Crystal, b::Bond, J)</code></pre><p>Given a reference bond <code>b</code> and coupling matrix <code>J</code> on that bond, return a list of symmetry-equivalent bonds and a corresponding list of symmetry-transformed coupling matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/AllowedCouplings.jl#L293-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.all_symmetry_related_couplings_for_atom-Tuple{Crystal, Int64, Bond, Any}" href="#Sunny.all_symmetry_related_couplings_for_atom-Tuple{Crystal, Int64, Bond, Any}"><code>Sunny.all_symmetry_related_couplings_for_atom</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_symmetry_related_couplings_for_atom(cryst::Crystal, i::Int, b::Bond, J)</code></pre><p>Given a reference bond <code>b</code> and coupling matrix <code>J</code> on that bond, return a list of symmetry-equivalent bonds (constrained to start from atom <code>i</code>), and a corresponding list of symmetry-transformed coupling matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/AllowedCouplings.jl#L271-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.anneal!-Union{Tuple{S}, Tuple{S, Any, Any}} where S&lt;:Sunny.AbstractSampler" href="#Sunny.anneal!-Union{Tuple{S}, Tuple{S, Any, Any}} where S&lt;:Sunny.AbstractSampler"><code>Sunny.anneal!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">anneal!(sampler, temp_schedule, step_schedule)</code></pre><p><code>sample!</code> a sampler at a series of temperatures, staying at each temperature   for the number of steps in <code>step_schedule</code>.</p><pre><code class="nohighlight hljs">anneal!(sampler, temp_function::Function, num_samples)</code></pre><p><code>sample!</code> a sampler <code>num_samples</code> times, with the sample at timestep <code>n</code>  drawn at a temperature <code>temp_function(n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Samplers.jl#L35-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.browser-Tuple{String}" href="#Sunny.browser-Tuple{String}"><code>Sunny.browser</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">browser(html_str; dir)</code></pre><p>Launch a system browser to display the provided HTML string or SunnyViewer. If a directory <code>dir</code> is provided, an HTML file will be written at that location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/SunnyGfx/SunnyGfx.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.calculate_structure_factor-Tuple{System, Sunny.AbstractSampler}" href="#Sunny.calculate_structure_factor-Tuple{System, Sunny.AbstractSampler}"><code>Sunny.calculate_structure_factor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_structure_factor(sys::System, sampler::LangevinSampler; nsamples=10, kwargs...)</code></pre><p>Calculates a <code>StructureFactor</code> containg <span>$ùíÆ(q,œâ)$</span> information with a single function call. Must be given a <a href="#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}"><code>System</code></a> and a <a href="#Sunny.LangevinSampler"><code>LangevinSampler</code></a>. This functions expects that the spin state contained in the <code>System</code> to already represent a good equilibrium sample. The function will use this state to generate an initial trajectory. After generating this first trajectory, it will call <code>sampler</code> before generating subsequent trajectories. In total, the function will calculate <code>nsamples</code> trajectories and accumulate them into a <code>StructureFactor</code> which is returned. The remaining keyword arguments are shared with <a href="#Sunny.StructureFactor-Tuple{System}"><code>StructureFactor</code></a>. </p><p>By default, this function will calculate the static structure factor, independent of dynamics. Specify a keyword argument <code>nœâ</code> greater than 1 to measure <span>$œâ$</span>-dependent dynamical quantities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/StructureFactors/StructureFactors.jl#L159-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.cell_type-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}" href="#Sunny.cell_type-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.cell_type</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_type(lat_vecs::Mat3)</code></pre><p>Infer the <code>CellType</code> of a unit cell from its lattice vectors, i.e. the columns of <code>lat_vecs</code>. Report an error if lattice vectors are not in conventional form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/LatticeUtils.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.cell_volume-Tuple{Crystal}" href="#Sunny.cell_volume-Tuple{Crystal}"><code>Sunny.cell_volume</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_volume(crystal::Crystal)</code></pre><p>Volume of the crystal unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Crystal.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.connected_path-Tuple{Vector, Any}" href="#Sunny.connected_path-Tuple{Vector, Any}"><code>Sunny.connected_path</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">connected_path(qs::Vector, density)</code></pre><p>Takes a list of wave vectors, <code>qs</code>, and builds an expanded list of wave vectors that traces a path through the provided points. Also returned is a list of marker indices corresponding to the intput points. The <code>density</code> parameter controls the frequency of sampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/StructureFactors/DataRetrieval.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.coordination_number-Tuple{Crystal, Int64, Bond}" href="#Sunny.coordination_number-Tuple{Crystal, Int64, Bond}"><code>Sunny.coordination_number</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coordination_number(cryst::Crystal, i::Int, b::Bond)</code></pre><p>Returns the number times that atom <code>i</code> participates in a bond equivalent to <code>b</code>. In other words, the count of bonds that begin at atom <code>i</code> and that are symmetry-equivalent to <code>b</code> or its reverse.</p><p>Defined as <code>length(all_symmetry_related_bonds_for_atom(cryst, i, b))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/SymmetryAnalysis.jl#L258-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.displacement-Tuple{Crystal, Sunny.BondRaw}" href="#Sunny.displacement-Tuple{Crystal, Sunny.BondRaw}"><code>Sunny.displacement</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">displacement(cryst::Crystal, b::Bond)</code></pre><p>The displacement vector <span>$ùê´_j - ùê´_i$</span> in global coordinates between atoms <code>b.i</code> and <code>b.j</code>, accounting for the integer offsets <code>b.n</code> between unit cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Bond.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.distance-Tuple{Crystal, Sunny.BondRaw}" href="#Sunny.distance-Tuple{Crystal, Sunny.BondRaw}"><code>Sunny.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(cryst::Crystal, b::Bond)</code></pre><p>The global distance between atoms in bond <code>b</code>. Equivalent to <code>norm(displacement(cryst, b))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Bond.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.dmvec-Tuple{Any}" href="#Sunny.dmvec-Tuple{Any}"><code>Sunny.dmvec</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dmvec(D)</code></pre><p>Representation of the Dzyaloshinskii-Moriya interaction pseudo-vector <code>D</code> as an antisymmetric matrix,</p><pre><code class="nohighlight hljs">  |  0   D‚ÇÉ -D‚ÇÇ |
  | -D‚ÇÉ  0   D‚ÇÅ |
  |  D‚ÇÇ -D‚ÇÅ  0  |</code></pre><p>Useful in the context of <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/PairExchanges.jl#L132-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.enable_dipole_dipole!-Tuple{System}" href="#Sunny.enable_dipole_dipole!-Tuple{System}"><code>Sunny.enable_dipole_dipole!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enable_dipole_dipole!(sys::System)</code></pre><p>Enables long-range dipole-dipole interactions,</p><p class="math-container">\[    -(Œº‚ÇÄ/4œÄ) ‚àë_{‚ü®ij‚ü©}  (3 (ùêå_j‚ãÖùê´ÃÇ_{ij})(ùêå_i‚ãÖùê´ÃÇ_{ij}) - ùêå_i‚ãÖùêå_j) / |ùê´_{ij}|^3\]</p><p>where the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are <span>$ùêå_i = Œº_B g ùêí_i$</span> where <span>$g$</span> is the g-factor or g-tensor, and <span>$ùêí_i$</span> is the spin angular momentum dipole in units of ƒß. The Bohr magneton <span>$Œº_B$</span> and vacuum permeability <span>$Œº_0$</span> are physical constants, with numerical values determined by the unit system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/Interactions.jl#L14-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.energy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy(sys::System)</code></pre><p>Computes the total system energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/Interactions.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.extend_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N" href="#Sunny.extend_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N"><code>Sunny.extend_periodically</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend_periodically(sys::System{N}, mults::NTuple{3, Int64}) where N</code></pre><p>Creates a new System identical to <code>sys</code> but with each dimension multiplied by the corresponding factor given in the tuple <code>mults</code>. The original spin configuration is simply repeated periodically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/System.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.filter_visited-Union{Tuple{BinnedArray{K, V}}, Tuple{V}, Tuple{K}} where {K, V}" href="#Sunny.filter_visited-Union{Tuple{BinnedArray{K, V}}, Tuple{V}, Tuple{K}} where {K, V}"><code>Sunny.filter_visited</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return only array elements that are visited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/WangLandau/BinnedArray.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N" href="#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N"><code>Sunny.forces</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forces(Array{Vec3}, sys::System)</code></pre><p>Returns the effective local field (force) at each site, <span>$ùêÅ = -‚àÇE/‚àÇùê¨$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/Interactions.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.get_intensities-Tuple{StructureFactor, Any, Any}" href="#Sunny.get_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.get_intensities</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_intensities(sf::StructureFactor, qs, mode; interpolation = nothing,
                   kT = nothing, formfactors = nothing, negative_energies = false)</code></pre><p>The basic function for retrieving <span>$ùíÆ(ùê™,œâ)$</span> information from a <code>StructureFactor</code>. Maps an array of wave vectors <code>qs</code> to an array of structure factor intensities, including an additional energy index. The values of <span>$œâ$</span> associated with the energy index can be retrieved by calling <a href="#Sunny.œâvals-Tuple{StructureFactor}"><code>œâvals</code></a>. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.</p><ul><li><code>mode</code>: Should be one of <code>:trace</code>, <code>:perp</code>, or <code>:full</code>. Determines an optional   contraction on the indices <span>$Œ±$</span> and <span>$Œ≤$</span> of <span>$ùíÆ^{Œ±Œ≤}(q,œâ)$</span>. Setting   <code>trace</code> yields <span>$‚àë_Œ± ùíÆ^{Œ±Œ±}(q,œâ)$</span>. Setting <code>perp</code> will employ a   polarization correction on the traced value. Setting <code>full</code> will return all   elements <span>$ùíÆ^{Œ±Œ≤}(q,œâ)$</span> with contraction.</li><li><code>interpolation</code>: Since <span>$ùíÆ(q,œâ)$</span> is calculated on a finite lattice, data is   only available at discrete wave vectors. By default, Sunny will round a   requested <code>q</code> to the nearest available wave vector. Linear interpolation can   be applied by setting <code>interpolation=:linear</code>.</li><li><code>kT</code>: If a temperature is provided, the intensities will be rescaled by a   temperature- and œâ-dependent classical-to-quantum factor. <code>kT</code> should be   specified when making comparisons with spin wave calculations or   experimental data.</li><li><code>formfactors</code>: To apply form factor corrections, provide this keyword with a   vector of <code>FormFactor</code>s, one for each unique site in the unit cell. Sunny   will symmetry propagate the results to all equivalent sites.</li><li><code>negative_energies</code>: If set to <code>true</code>, Sunny will return the periodic   extension of the energy axis. Most users will not want this.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/StructureFactors/DataRetrieval.jl#L68-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.get_static_intensities-Tuple{StructureFactor, Any, Any}" href="#Sunny.get_static_intensities-Tuple{StructureFactor, Any, Any}"><code>Sunny.get_static_intensities</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_static_intensities(sf::StructureFactor, qs, mode; kwargs...)</code></pre><p>Return the static structure factor intensities at wave vectors <code>qs</code>. The functionality is very similar to <a href="#Sunny.get_intensities-Tuple{StructureFactor, Any, Any}"><code>get_intensities</code></a>, except the returned array has dimensions identical to <code>qs</code>. The energy axis has been summed out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/StructureFactors/DataRetrieval.jl#L167-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.get_temp-Tuple{MetropolisSampler}" href="#Sunny.get_temp-Tuple{MetropolisSampler}"><code>Sunny.get_temp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_temp(sampler) :: Float64</code></pre><p>Returns the temperature of the sampler, as <code>kT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Samplers.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.init_bounded!-Tuple{WangLandau}" href="#Sunny.init_bounded!-Tuple{WangLandau}"><code>Sunny.init_bounded!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Initialize system to bounded range of states using throw-away WL sampling run see run!(...) for comments explaining code in init loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/WangLandau/WangLandau.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.intensity_grid-Tuple{StructureFactor, Any}" href="#Sunny.intensity_grid-Tuple{StructureFactor, Any}"><code>Sunny.intensity_grid</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intensity_grid(sf::StructureFactor, mode;
                   bzsize=(1,1,1), negative_energies = false, index_labels = false, kwargs...)</code></pre><p>Returns intensities at discrete wave vectors for which there is exact information. Shares all keywords with <a href="#Sunny.get_intensities-Tuple{StructureFactor, Any, Any}"><code>get_intensities</code></a>, and provides two additional options:</p><ul><li><code>bzsize</code>: Specifies the number of Brillouin zones to return, given as a 3-tuple of integers.</li><li><code>index_labels</code>: If set to <code>true</code>, will return axis label information for the   data, which may be upacked as: <code>(; intensities, qpoints, œâs)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/StructureFactors/DataRetrieval.jl#L183-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}" href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>Sunny.lattice_params</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_params(lat_vecs::Mat3)</code></pre><p>Compute the lattice parameters <span>$(a, b, c, Œ±, Œ≤, Œ≥)$</span> for the three lattice vectors provided as columns of <code>lat_vecs</code>. The inverse mapping is <a href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>lattice_vectors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/LatticeUtils.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.lattice_vectors-NTuple{6, Any}" href="#Sunny.lattice_vectors-NTuple{6, Any}"><code>Sunny.lattice_vectors</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_vectors(a, b, c, Œ±, Œ≤, Œ≥)</code></pre><p>Return the lattice vectors, as columns of the <span>$3√ó3$</span> output matrix, that correspond to the conventional unit cell defined by the lattice constants <span>$(a, b, c)$</span> and the angles <span>$(Œ±, Œ≤, Œ≥)$</span> in degrees. The inverse mapping is <a href="#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}"><code>lattice_params</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/LatticeUtils.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.nbasis-Tuple{Crystal}" href="#Sunny.nbasis-Tuple{Crystal}"><code>Sunny.nbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nbasis(crystal::Crystal)</code></pre><p>Number of basis positions (sublattices) in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Crystal.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_anisotropy_as_classical_spins-Tuple{Any}" href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>Sunny.print_anisotropy_as_classical_spins</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_anisotropy_as_classical_spins(p)</code></pre><p>Prints a quantum operator (e.g. linear combination of Stevens operators) as a polynomial of spin expectation values in the classical limit.</p><p>See also <a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>print_anisotropy_as_stevens</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/LocalOperators.jl#L323-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_anisotropy_as_stevens-Tuple{Any}" href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>Sunny.print_anisotropy_as_stevens</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function print_anisotropy_as_stevens(p; N)</code></pre><p>Prints a quantum operator (e.g. a polynomial of the spin operators <code>ùíÆ</code>) as a linear combination of Stevens operators. The parameter <code>N</code> specifies the dimension of the SU(<em>N</em>) representation, corresponding to quantum spin magnitude <span>$S = (N-1)/2$</span>. The special value <code>N = 0</code> indicates the large-<span>$S$</span> classical limit.</p><p>In the output, the symbol <code>X</code> denotes the spin operator magnitude squared. Quantum spin operators <span>$ùíÆ$</span> of any finite dimension satisfy <span>$X = |ùíÆ|^2 = S (S+1)$</span>. To take the large-<span>$S$</span> limit, however, we keep only leading order powers of <span>$S$</span>, such that <span>$X = S^2$</span>.</p><p>This function can be useful for understanding the conversions performed internally by <a href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>set_anisotropy!</code></a>.</p><p>For the inverse mapping, see <a href="#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}"><code>print_anisotropy_as_classical_spins</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/LocalOperators.jl#L337-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_bond-Tuple{Crystal, Bond}" href="#Sunny.print_bond-Tuple{Crystal, Bond}"><code>Sunny.print_bond</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)</code></pre><p>Prints symmetry information for bond <code>bond</code>. A symmetry-equivalent reference bond <code>b_ref</code> can optionally be provided to fix the meaning of the coefficients <code>A</code>, <code>B</code>, ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Printing.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_site-Tuple{Any, Any}" href="#Sunny.print_site-Tuple{Any, Any}"><code>Sunny.print_site</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>print_site(cryst, i; R=I)</p><p>Print symmetry information for the site <code>i</code>, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix <code>R</code> can be provided to define the reference frame for expression of the anisotropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Printing.jl#L217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_suggested_frame-Tuple{Crystal, Int64}" href="#Sunny.print_suggested_frame-Tuple{Crystal, Int64}"><code>Sunny.print_suggested_frame</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>print<em>suggested</em>frame(cryst, i; digits=4)</p><p>Print a suggested reference frame, as a rotation matrix <code>R</code>, that can be used as input to <code>print_site()</code>. This is useful to simplify the description of allowed anisotropies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Printing.jl#L198-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.print_symmetry_table-Tuple{Crystal, Any}" href="#Sunny.print_symmetry_table-Tuple{Crystal, Any}"><code>Sunny.print_symmetry_table</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_symmetry_table(cryst::Crystal, max_dist)</code></pre><p>Print symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of <code>max_dist</code>. Equivalent to calling <code>print_bond(cryst, b)</code> for every bond <code>b</code> in <code>reference_bonds(cryst, max_dist)</code>, where <code>Bond(i, i, [0,0,0])</code> refers to a single site <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Printing.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.reference_bonds-Tuple{Crystal, Float64}" href="#Sunny.reference_bonds-Tuple{Crystal, Float64}"><code>Sunny.reference_bonds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reference_bonds(cryst::Crystal, max_dist)</code></pre><p>Returns a full list of bonds, one for each symmetry equivalence class, up to distance <code>max_dist</code>. The reference bond <code>b</code> for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in <code>basis_for_symmetry_allowed_couplings(cryst, b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/SymmetryAnalysis.jl#L197-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.reset!-Union{Tuple{BinnedArray{K, V}}, Tuple{V}, Tuple{K}} where {K, V}" href="#Sunny.reset!-Union{Tuple{BinnedArray{K, V}}, Tuple{V}, Tuple{K}} where {K, V}"><code>Sunny.reset!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Set all values to 0 and if specified, reset all visited flags to false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/WangLandau/BinnedArray.jl#L80-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.run!-Tuple{WangLandau}" href="#Sunny.run!-Tuple{WangLandau}"><code>Sunny.run!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Run a Wang-Landau simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/WangLandau/WangLandau.jl#L236-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.sample!-Union{Tuple{MetropolisSampler{N}}, Tuple{N}} where N" href="#Sunny.sample!-Union{Tuple{MetropolisSampler{N}}, Tuple{N}} where N"><code>Sunny.sample!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample!(sampler)</code></pre><p>Samples <code>sampler.sys</code> to a new state, under the Boltzmann distribution  as defined by <code>sampler.sys.interactions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Samplers.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N" href="#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N"><code>Sunny.set_anisotropy!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_anisotropy!(sys::System, op, i::Int)</code></pre><p>Set the single-ion anisotropy for the <code>i</code>th atom of every unit cell, as well as all symmetry-equivalent atoms. The parameter <code>op</code> may be a polynomial in symbolic spin operators <code>ùíÆ[Œ±]</code>, or a linear combination of symbolic Stevens operators <code>ùí™[k,q]</code>.</p><p>The characters <code>ùíÆ</code> and <code>ùí™</code> can be copy-pasted from this help message, or typed at a Julia terminal using <code>\scrS</code> or <code>\scrO</code> followed by tab-autocomplete.</p><p>For systems with <code>mode=:projected</code>, the anisotropy operators interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(<em>N</em>) mode.</p><p><strong>Examples</strong></p><p>```julia</p><p><strong>An easy axis anisotropy in the z-direction</strong></p><p>set_anisotropy!(sys, -D*ùíÆ[3]^3, i)</p><p><strong>The unique quartic single-ion anisotropy for a site with cubic point group</strong></p><p><strong>symmetry</strong></p><p>set_anisotropy!(sys, ùí™[4,0] + 5ùí™[4,4], i)</p><p><strong>An equivalent expression of this quartic anisotropy, up to a constant shift</strong></p><p>set_anisotropy!(sys, 20*(ùíÆ[1]^4 + ùíÆ[2]^4 + ùíÆ[3]^4), i)</p><p>See also <a href="#Sunny.print_anisotropy_as_stevens-Tuple{Any}"><code>print_anisotropy_as_stevens</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/SingleIonAnisotropies.jl#L15-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N" href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>Sunny.set_exchange!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange!(sys::System, J, bond::Bond)</code></pre><p>Sets a 3√ó3 spin-exchange matrix <code>J</code> along <code>bond</code>, yielding a pairwise interaction energy <span>$ùêí_i‚ãÖJ ùêí_j$</span>. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten. The parameter <code>bond</code> has the form <code>Bond(i, j, offset)</code>, where <code>i</code> and <code>j</code> are atom indices within the unit cell, and <code>offset</code> is a displacement in unit cells.</p><p>Scalar <code>J</code> implies a pure Heisenberg exchange.</p><p>As a convenience, <code>dmvec(D)</code> can be used to construct the antisymmetric part of the exchange, where <code>D</code> is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be <span>$ùêÉ‚ãÖ(ùêí_i√óùêí_j)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Sunny, LinearAlgebra

# An explicit exchange matrix
J1 = [2 3 0;
     -3 2 0;
      0 0 2]
set_exchange!(sys, J1, bond)

# An equivalent Heisenberg + DM exchange 
J2 = 2*I + dmvec([0,0,3])
set_exchange!(sys, J2, bond)</code></pre><p>See also <a href="#Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N"><code>set_exchange_with_biquadratic!</code></a>, <a href="#Sunny.dmvec-Tuple{Any}"><code>dmvec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/PairExchanges.jl#L94-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N" href="#Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N"><code>Sunny.set_exchange_with_biquadratic!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_exchange_with_biquadratic!(sys::System, J, J‚Ä≤, bond::Bond)</code></pre><p>Sets both quadratic and biquadratic exchange interactions along <code>bond</code>, yielding a pairwise energy <span>$ùêí_i‚ãÖJ ùêí_j + J‚Ä≤ (ùêí_i‚ãÖùêí_j)¬≤$</span>. These interactions will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten.</p><p>For systems with <code>mode=:projected</code> the biquadratic interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(<em>N</em>) mode. This renormalization introduces a correction to the quadratic part of the exchange, which is why the two parts must be specified concurrently.</p><p>See also <a href="#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N"><code>set_exchange!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/PairExchanges.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_external_field!-Tuple{System, Any}" href="#Sunny.set_external_field!-Tuple{System, Any}"><code>Sunny.set_external_field!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_external_field!(sys::System, B::Vec3)</code></pre><p>Introduce a Zeeman coupling between all spins and an applied magnetic field <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/Interactions.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_local_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N" href="#Sunny.set_local_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N"><code>Sunny.set_local_anisotropy!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_local_anisotropy!(sys::System, op, idx)</code></pre><p>Set a single-ion anisotropy for a single spin at <code>idx</code>, in violation of crystal periodicity. No symmetry analysis will be performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/SingleIonAnisotropies.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_local_external_field!-Tuple{System, Any, Any}" href="#Sunny.set_local_external_field!-Tuple{System, Any, Any}"><code>Sunny.set_local_external_field!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_local_external_field!(sys::System, B::Vec3, idx::CartesianIndex{4})</code></pre><p>Introduce an applied field <code>B</code> localized to a single spin at <code>idx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/System/Interactions.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.set_temp!-Tuple{MetropolisSampler, Any}" href="#Sunny.set_temp!-Tuple{MetropolisSampler, Any}"><code>Sunny.set_temp!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_temp!(sampler, kT)</code></pre><p>Changes the temperature of the sampler to <code>kT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Samplers.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.step!-Tuple{System{0}, LangevinHeunP}" href="#Sunny.step!-Tuple{System{0}, LangevinHeunP}"><code>Sunny.step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step!(sys::System, integrator)</code></pre><p>Advance the spin system forward one step using the parameters and integration scheme specified by <code>integrator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Integrators.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N" href="#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N"><code>Sunny.subcrystal</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcrystal(cryst, types) :: Crystal</code></pre><p>Filters sublattices of a <code>Crystal</code> by atom <code>types</code>, keeping the space group unchanged.</p><pre><code class="nohighlight hljs">subcrystal(cryst, classes) :: Crystal</code></pre><p>Filters sublattices of <code>Crystal</code> by equivalence <code>classes</code>, keeping the space group unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Symmetry/Crystal.jl#L392-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.thermalize!-Union{Tuple{S}, Tuple{S, Int64}} where S&lt;:Sunny.AbstractSampler" href="#Sunny.thermalize!-Union{Tuple{S}, Tuple{S, Int64}} where S&lt;:Sunny.AbstractSampler"><code>Sunny.thermalize!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thermalize!(sampler, num_samples)</code></pre><p><code>sample!</code> a sampler a given number of times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/Samplers.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.view_crystal-Tuple{Crystal, Real}" href="#Sunny.view_crystal-Tuple{Crystal, Real}"><code>Sunny.view_crystal</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_crystal(crystal::Crystal, max_dist::Real)</code></pre><p>Create and show crystal viewer in a VSCode or Jupyter notebook environment. The result can also be displayed using <code>browser()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/SunnyGfx/CrystalViewer.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sunny.œâvals-Tuple{StructureFactor}" href="#Sunny.œâvals-Tuple{StructureFactor}"><code>Sunny.œâvals</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">œâvals(sf::StructureFactor)</code></pre><p>Return the œâ-values associated with the energy index of a <code>StructureFactor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SunnySuite/Sunny.jl/blob/2bacf8276f41b788f3e5d230f27739e1ffa2aa67/src/StructureFactors/SFUtils.jl#L14-L18">source</a></section></article><p>&lt;!‚Äì </p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>To reduce package load times, Sunny plotting functions are initially hidden, and only become available when the user explicitly executes &quot;<code>using GLMakie</code>&quot;. It is a good idea to check that the <a href="https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie">GLMakie</a> installation is working correctly (execute &quot;<code>] test GLMakie</code>&quot; from the Julia REPL).</p><pre><code class="language-_AT_docs hljs">plot_lattice
plot_spins
plot_bonds
plot_all_bonds
anim_integration
live_integration
live_langevin_integration</code></pre><p>‚Äì&gt;</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quick-start/">¬´ Quick Start</a><a class="docs-footer-nextpage" href="../structure-factor/">Structure Factor Calculations ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 22 January 2023 00:44">Sunday 22 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
