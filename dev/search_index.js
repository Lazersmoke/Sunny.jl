var documenterSearchIndex = {"docs":
[{"location":"versions/#Version-0.4","page":"Version History","title":"Version 0.4","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"This update includes many breaking changes.","category":"page"},{"location":"versions/#Creating-a-spin-System","page":"Version History","title":"Creating a spin System","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"SpinSystem has been renamed System. Its constructor now has the form,","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"System(crystal, latsize, infos, mode)","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The parameter infos is now a list of SpinInfo objects involving spin angular momentum S = (12 1 32 ) and an optional g-factor or tensor.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The parameter mode which must be one of :dipole, :SUN, or :projected. ","category":"page"},{"location":"versions/#Setting-interactions","page":"Version History","title":"Setting interactions","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Interactions are now added mutably to an existing System using the following functions: set_external_field!, set_exchange!, set_exchange_with_biquadratic!, set_anisotropy!, enable_dipole_dipole!.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"As a convenience, one can use dmvec(D) to convert a DM vector to a 33 antisymmetric exchange matrix.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Fully general single-ion anisotropy is now possible. The function set_anisotropy! expects the single ion anisotropy to be expressed as a polynomial in symbolic spin operators ğ’®, or as a linear combination of symbolic Stevens operators ğ’ª.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"Stevens operators ğ’ª[k,q] admit polynomial expression in spin operators ğ’®[Î±]. Conversely, a polynomial of spin operators can be expressed as a linear combination of Stevens operators. To see this expansion use print_anisotropy_as_stevens.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"There is no longer a helper function to create an easy-axis or easy-plane anisotropy. Instead use D*(ğ’®â‹…n)^2, or similar.","category":"page"},{"location":"versions/#Inhomogeneous-interactions-(Planned)","page":"Version History","title":"Inhomogeneous interactions (Planned)","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"Spatially inhomogeneous interactions can be get or set using the following methods:","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"set_vacancy_at!(sys, idx)\n\nset_external_field_at!(sys, h, idx)\nget_external_field_at!(sys, idx)\n\nenable_inhomogeneous_exchange!(sys) # Once enabled, cannot be disabled\n\nset_exchange_at!(sys, J, idx)\nget_exchange_at(sys, idx)","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The parameter idx has the shape (n1, n2, n3, atom), where (n1,n2,n3) labels a unit cell, and atom is an index within this unit cell.","category":"page"},{"location":"versions/#Structure-factor-rewrite","page":"Version History","title":"Structure factor rewrite","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"The calculation of structure factors has been completely rewritten. For the new interface, see the Structure Factor Calculations page.","category":"page"},{"location":"versions/#Various","page":"Version History","title":"Various","text":"","category":"section"},{"location":"versions/","page":"Version History","title":"Version History","text":"print_symmetry_table() replaces print_bond_table().","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"The new function includes the list of symmetry-allowed single ion anisotropies in addition to exchange interactions.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"When reading CIF files, the field _atom_site_label is now used in place of the field _atom_site_type_symbol.","category":"page"},{"location":"versions/","page":"Version History","title":"Version History","text":"This is required for correctness. The field _atom_site_label is guaranteed to be present, and is guaranteed to be a distinct label for each symmetry-inequivalent site. Code that explicitly referred to site labels (e.g. in calls to subcrystal()) will need to be updated to use the new label.","category":"page"},{"location":"library/#Library-API","page":"Library API","title":"Library API","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"This page describes the public types and functions exported by Sunny. This documentation can be also be accessed using the Julia help system (enter ? at the Julia command prompt).","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"Modules = [Sunny]\nPrivate = false","category":"page"},{"location":"library/#Sunny.Units","page":"Library API","title":"Sunny.Units","text":"Units.meV\nUnits.theory\n\nThe unit system is implicitly determined by the definition of two physical constants: the vacuum permeability Î¼â‚€ and the Bohr magneton Î¼_B. Temperatures are effectively measured in units of energy (k_B = 1) and time is effectively measured in units of inverse energy (Ä§ = 1). The default unit system, Units.meV, employs (meV, â„«, tesla). Select alternatively Units.theory for a units system defined so that Î¼â‚€ = Î¼_B = 1.\n\nSee also meV_per_K\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.meV_per_K","page":"Library API","title":"Sunny.meV_per_K","text":"meV_per_K = 0.086173332621451774\n\nA physical constant. Useful for converting kelvin into the default energy units, meV.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.ğ’ª","page":"Library API","title":"Sunny.ğ’ª","text":"ğ’ª[k,q]\n\nAbstract symbols for the Stevens operators. Linear combinations of these can be used to specify the single-ion anisotropy.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.ğ’®","page":"Library API","title":"Sunny.ğ’®","text":"ğ’®[1], ğ’®[2], ğ’®[3]\n\nAbstract symbols for the spin operators. Polynomials of these can be used to specify the single-ion anisotropy.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Sunny.BinnedArray","page":"Library API","title":"Sunny.BinnedArray","text":"mutable struct BinnedArray{K, V}\n\nAdaptive array that bins data. Can be used as a histogram. Just 1D now, but could use raveled index if necessary.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Bond","page":"Library API","title":"Sunny.Bond","text":"Bond(i, j, n)\n\nRepresents a bond between atom indices i and j. n is a vector of three integers specifying unit cell displacement in terms of lattice vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.Crystal","page":"Library API","title":"Sunny.Crystal","text":"An object describing a crystallographic unit cell and its space group symmetry. Constructors are as follows:\n\nCrystal(filename; symprec=1e-5)\n\nReads the crystal from a .cif file located at the path filename.  The optional parameter symprec controls the precision tolerance for spacegroup symmetries.\n\nCrystal(lat_vecs, positions; types=nothing, symprec=1e-5)\n\nConstructs a crystal from the complete list of atom positions positions, with coordinates (between 0 and 1) in units of lattice vectors lat_vecs. Spacegroup symmetry information is automatically inferred. The optional parameter types is a list of strings, one for each atom, and can be used to break symmetry-equivalence between atoms.\n\nCrystal(lat_vecs, positions, spacegroup_number; types=nothing, setting=nothing, symprec=1e-5)\n\nBuilds a crystal by applying symmetry operators for a given international spacegroup number. For certain spacegroups, there are multiple possible unit cell settings; in this case, a warning message will be printed, and a list of crystals will be returned, one for every possible setting. Alternatively, the optional setting string will disambiguate between unit cell conventions.\n\nExamples\n\n# Read a Crystal from a .cif file\nCrystal(\"filename.cif\")\n\n# Build an FCC crystal using the primitive unit cell. The spacegroup number\n# 225 is inferred.\nlat_vecs = [1 1 0;\n            1 0 1;\n            0 1 1] / 2\npositions = [[0, 0, 0]]\nCrystal(lat_vecs, positions)\n\n# Build a CsCl crystal (two cubic sublattices). By providing distinct type\n# strings, the spacegroup number 221 is inferred.\nlat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)\npositions = [[0,0,0], [0.5,0.5,0.5]]\ntypes = [\"Na\", \"Cl\"]\ncryst = Crystal(lat_vecs, positions; types)\n\n# Build a diamond cubic crystal from its spacegroup number 227. This\n# spacegroup has two possible settings (\"1\" or \"2\"), which determine an\n# overall unit cell translation.\nlat_vecs = lattice_vectors(1, 1, 1, 90, 90, 90)\npositions = [[1, 1, 1] / 4]\ncryst = Crystal(lat_vecs, positions, 227; setting=\"1\")\n\nSee also lattice_vectors.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.FormFactor-Tuple{Int64, Union{Nothing, String}}","page":"Library API","title":"Sunny.FormFactor","text":"FormFactor(atom::Int64, elem::String; g_lande=nothing)\n\nBasic type for specifying form factor parameters. Must be provided a site within the unit cell (atom) and a string specifying the element name. This used when calling get_intensities, which requires a list of FormFactorss.\n\nA list of supported element names is available at:\n\nhttps://www.ill.eu/sites/ccsl/ffacts/ffachtml.html\n\nThe LandÃ© g-factor may also be specified. \n\nIn more detail, the data stored in a FormFactor will be used to compute the form factor for each momentum space magnitude |k|, measured in inverse angstroms. The result is dependent on the magnetic ion species. By default, a first order form factor f is returned. If the keyword g_lande is given a numerical value, then a second order form factor F is returned.\n\nIt is traditional to define the form factors using a sum of Gaussian broadening functions in the scalar variable s = k4Ï€, where k can be interpreted as the magnitude of momentum transfer.\n\nThe Neutron Data Booklet, 2nd ed., Sec. 2.5 Magnetic Form Factors, defines the approximation\n\nlangle j_l(s) rangle = A e^-as^2 + B e^-bs^2 + Ce^-cs^2 + D\n\nwhere coefficients A B C D a b c are obtained from semi-empirical fits, depending on the orbital angular momentum index l = 0 2. For transition metals, the form-factors are calculated using the Hartree-Fock method. For rare-earth metals and ions, Dirac-Fock form is used for the calculations.\n\nA first approximation to the magnetic form factor is\n\nf(s) = langle j_0(s) rangle\n\nA second order correction is given by\n\nF(s) = frac2-gg langle j_2(s) rangle s^2 + f(s), where g is the LandÃ© g-factor.  \n\nDigital tables are available at:\n\nhttps://www.ill.eu/sites/ccsl/ffacts/ffachtml.html\n\nAdditional references are:\n\nMarshall W and Lovesey S W, Theory of thermal neutron scattering Chapter 6 Oxford University Press (1971)\nClementi E and Roetti C,  Atomic Data and Nuclear Data Tables, 14 pp 177-478 (1974)\nFreeman A J and Descleaux J P, J. Magn. Mag. Mater., 12 pp 11-21 (1979)\nDescleaux J P and Freeman A J, J. Magn. Mag. Mater., 8 pp 119-129 (1978) \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.ImplicitMidpoint","page":"Library API","title":"Sunny.ImplicitMidpoint","text":"ImplicitMidpoint(Î”t::Float64; atol=1e-12) where N\n\nEnergy-conserving integrator for simulating dynamics without damping or noise. Use with the step! function to evolve a System forward by a time step of Î”t:\n\nstep!(sys::System, integrator::ImplicitMidpoint)\n\nThe above function will use the spherical midpoint integration scheme for dipole systems and the Schrodinger midpoint integration scheme for SU(N) spin systems. Both integration schemes are symplectic (energy-conserving) and are appropriate for simulating dissipationless dynamics over long periods of time.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.IsingSampler","page":"Library API","title":"Sunny.IsingSampler","text":"IsingSampler(sys::System, kT::Float64, nsweeps::Int)\n\nA sampler which performs the standard Metropolis Monte Carlo algorithm to sample a System at the requested temperature.\n\nThis version differs from MetropolisSampler in that each single-spin update only attempts to completely flip the spin. One call to sample! will attempt to flip each spin nsweeps times.\n\nBefore constructing, be sure that your System is initialized so that each spin points along its \"Ising-like\" axis.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.LangevinHeunP","page":"Library API","title":"Sunny.LangevinHeunP","text":"LangevinHeunP(kT::Float64, Î»::Float64, Î”t::Float64)\n\nProjected Heun integration scheme with noise and damping. Use with the step! function to evolve a System forward by a time step of Î”t:\n\nstep!(sys::System, integrator::LangevinHeunP)\n\nIf kT > 0, this will simulate dynamics in the presence of a thermal bath. Î» is an empirical parameter that determines the strength of coupling to the thermal bath and sets a time scale for decorrelation, 1/Î».\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.LangevinSampler","page":"Library API","title":"Sunny.LangevinSampler","text":"LangevinSampler(integrator::LangevinHeunP, nsteps::Int)\n\nCreates a sampler from a Langevin integrator. nsteps determines how many times step! is called using the integrator. nsteps should be selected large enough to ensure that the state of the System after integration is decorrelated with respect to its initial state.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.MetropolisSampler","page":"Library API","title":"Sunny.MetropolisSampler","text":"MetropolisSampler(sys::System, kT::Float64, nsweeps::Int)\n\nA sampler which performs the standard Metropolis Monte Carlo algorithm to sample  a System at the requested temperature.\n\nEach single-spin update attempts to completely randomize the spin. One call to  sample! will attempt to flip each spin nsweeps times.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.SpinInfo","page":"Library API","title":"Sunny.SpinInfo","text":"SpinInfo(atom::Int; S, g=2)\n\nCharacterizes the spin at a given atom index within the crystal unit cell. S is an integer multiple of 1/2 and gives the spin angular momentum in units of Ä§. g is the g-factor or tensor, such that an angular momentum dipole s produces a magnetic moment g s in units of the Bohr magneton.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.StructureFactor-Tuple{System}","page":"Library API","title":"Sunny.StructureFactor","text":"StructureFactor(sys::System; Î”t = 0.1, nÏ‰ = 1, Ï‰max = nothing,\n                    apply_g = true, ops = nothing, matrix_elems = nothing)\n\nStructureFactor is the basic type for calculating ğ’®^Î±Î²(qÏ‰), storing the results, and retrieving intensity information. \n\nMost users should use calculate_structure_factor to generate a structure factor. However, one may also directly create a structure factor by providing a System to StructureFactor. Then, to manually generate a sample, the user must ensure that the spins of their system are drawn from an appropriate equilibrium distribution and call add_trajectory! function. This process may be repeated as necessary to generate a sufficient statistics. \n\nThe keywords specify all the parameters used in subsequent calculations and must be determined at the time that the StructureFactor is initiated. Specifically:\n\nÎ”t: Sets the step size of the integrator used to calculate trajectories.\nÏ‰max: Determines the maximum resolved energy.\nnÏ‰: Determines how many energy bins to resolve between 0 and Ï‰max. If set   to 1, Sunny will calculate a static structure factor.\napply_g: Determines whether to apply the g-factor when calculating   trajectories.\nops: Enables an advanced feature for SU(N) mode, allowing the user to   specify custom observables other than the three components of the dipole. To   use this features, ops must be given an NÃ—NÃ—numops array, where the   final index is used to retrieve each NÃ—N operator.\nmatrix_elems: Allows the user to specify which correlation functions are   calculated. This is specified with a vector of tuples. By default Sunny   records all auto- and cross-correlations generated by the x, y, and z   dipolar components. To retain only the xx and xy correlations, one would set   matrix_elems=[(1,1), (1,2)].\nprocess_trajectory: Specify any preprocessing that should be applied to a   recorded trajectory before calculating correlations. By default, no   processing is applied. Options are :symmetrize, which symmetrizes the   trajectory, and :subtract_mean, which subtracts the mean value. Both   options are useful for eliminating Fourier artifacts that frequently appear   when simulating gapless, or nearly gapless, Hamiltonians.\n\nIf you wish to calculate a dynamical structure factor, the keyword nÏ‰ must set to an integer greater than 1.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.System-Tuple{Crystal, Tuple{Int64, Int64, Int64}, Vector{SpinInfo}, Symbol}","page":"Library API","title":"Sunny.System","text":"System(crystal::Crystal, latsize, infos, mode; units=Units.meV, seed::Int)\n\nConstruct a System of spins for a given crystal symmetry. The latsize parameter determines the number of unit cells in each lattice vector direction. The infos parameter is a list of SpinInfo objects, which determine the magnitude S and g-tensor of each spin.\n\nThe three possible options for mode are :dipole, :SUN, and :projected. The choice :dipole restricts the description of a spin to its angular momentum dipole. The choice :SUN will expand the description of a spin to a full SU(N) coherent state, where N = 2S + 1. This approach captures more quantum mechanical degrees of freedom, e.g., the dynamics of quadrupolar fluctuations Sáµ…Sáµ+SáµSáµ…. Finally, the choice :projected produces the SU(N) dynamics but projected to the space of dipoles. In practice, the distinction between :projected and :dipoles is that the former will automatically apply appropriate renormalizations to the single-ion anisotropy and biquadratic exchange interactions for maximum accuracy.\n\nThe default units system of (meV, â„«, tesla) can be overridden by with the units parameter; see Units. \n\nAll spins are initially polarized in the z-direction.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.WangLandau","page":"Library API","title":"Sunny.WangLandau","text":"mutable struct WangLandau{F<:Function}\n\nWang-Landau sampler. All parameters have default values that can be overwritten, but a System must be passed during construction. \n\n\n\n\n\n","category":"type"},{"location":"library/#Sunny.add_trajectory!-Tuple{StructureFactor, System}","page":"Library API","title":"Sunny.add_trajectory!","text":"add_trajectory!(sf::StructureFactor, sys::System)\n\nWhen given a StructureFactor and a System, add_trajectory will use the spin state contained in the System as the initial condition for a dynamical trajectory. The correlations generated by the trajectory are calculated and accumulated into the StructureFactor. All trajectory parameters are specified in the StructureFactor.\n\nNote that this function will not change the spin state in sys. \n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.all_symmetry_related_anisotropies-Tuple{Crystal, Int64, Any}","page":"Library API","title":"Sunny.all_symmetry_related_anisotropies","text":"all_symmetry_related_anisotropies(cryst, i_ref, Î›_ref)\n\nReturn two lists. The first list contains all atoms i that are symmetry equivalent to i_ref. The second list contains the appropriately transformed anisotropy matrices Î› for each site i.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.all_symmetry_related_bonds-Tuple{Crystal, Bond}","page":"Library API","title":"Sunny.all_symmetry_related_bonds","text":"all_symmetry_related_bonds(cryst::Crystal, b::Bond)\n\nReturns a list of all bonds that are symmetry-equivalent to bond b or its reverse.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.all_symmetry_related_bonds_for_atom-Tuple{Crystal, Int64, Bond}","page":"Library API","title":"Sunny.all_symmetry_related_bonds_for_atom","text":"all_symmetry_related_bonds_for_atom(cryst::Crystal, i::Int, b::Bond)\n\nReturns a list of all bonds that start at atom i, and that are symmetry equivalent to bond b or its reverse.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.all_symmetry_related_couplings-Tuple{Crystal, Bond, Any}","page":"Library API","title":"Sunny.all_symmetry_related_couplings","text":"all_symmetry_related_couplings(cryst::Crystal, b::Bond, J)\n\nGiven a reference bond b and coupling matrix J on that bond, return a list of symmetry-equivalent bonds and a corresponding list of symmetry-transformed coupling matrices.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.all_symmetry_related_couplings_for_atom-Tuple{Crystal, Int64, Bond, Any}","page":"Library API","title":"Sunny.all_symmetry_related_couplings_for_atom","text":"all_symmetry_related_couplings_for_atom(cryst::Crystal, i::Int, b::Bond, J)\n\nGiven a reference bond b and coupling matrix J on that bond, return a list of symmetry-equivalent bonds (constrained to start from atom i), and a corresponding list of symmetry-transformed coupling matrices.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.anneal!-Union{Tuple{S}, Tuple{S, Any, Any}} where S<:Sunny.AbstractSampler","page":"Library API","title":"Sunny.anneal!","text":"anneal!(sampler, temp_schedule, step_schedule)\n\nsample! a sampler at a series of temperatures, staying at each temperature   for the number of steps in step_schedule.\n\nanneal!(sampler, temp_function::Function, num_samples)\n\nsample! a sampler num_samples times, with the sample at timestep n  drawn at a temperature temp_function(n).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.browser-Tuple{String}","page":"Library API","title":"Sunny.browser","text":"browser(html_str; dir)\n\nLaunch a system browser to display the provided HTML string or SunnyViewer. If a directory dir is provided, an HTML file will be written at that location.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.calculate_structure_factor-Tuple{System, Sunny.AbstractSampler}","page":"Library API","title":"Sunny.calculate_structure_factor","text":"calculate_structure_factor(sys::System, sampler::LangevinSampler; nsamples=10, kwargs...)\n\nCalculates a StructureFactor containg ğ’®(qÏ‰) information with a single function call. Must be given a System and a LangevinSampler. This functions expects that the spin state contained in the System to already represent a good equilibrium sample. The function will use this state to generate an initial trajectory. After generating this first trajectory, it will call sampler before generating subsequent trajectories. In total, the function will calculate nsamples trajectories and accumulate them into a StructureFactor which is returned. The remaining keyword arguments are shared with StructureFactor. \n\nBy default, this function will calculate the static structure factor, independent of dynamics. Specify a keyword argument nÏ‰ greater than 1 to measure Ï‰-dependent dynamical quantities.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.cell_type-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Library API","title":"Sunny.cell_type","text":"cell_type(lat_vecs::Mat3)\n\nInfer the CellType of a unit cell from its lattice vectors, i.e. the columns of lat_vecs. Report an error if lattice vectors are not in conventional form.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.cell_volume-Tuple{Crystal}","page":"Library API","title":"Sunny.cell_volume","text":"cell_volume(crystal::Crystal)\n\nVolume of the crystal unit cell.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.connected_path-Tuple{Vector, Any}","page":"Library API","title":"Sunny.connected_path","text":"connected_path(qs::Vector, density)\n\nTakes a list of wave vectors, qs, and builds an expanded list of wave vectors that traces a path through the provided points. Also returned is a list of marker indices corresponding to the intput points. The density parameter controls the frequency of sampling.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.coordination_number-Tuple{Crystal, Int64, Bond}","page":"Library API","title":"Sunny.coordination_number","text":"coordination_number(cryst::Crystal, i::Int, b::Bond)\n\nReturns the number times that atom i participates in a bond equivalent to b. In other words, the count of bonds that begin at atom i and that are symmetry-equivalent to b or its reverse.\n\nDefined as length(all_symmetry_related_bonds_for_atom(cryst, i, b)).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.displacement-Tuple{Crystal, Sunny.BondRaw}","page":"Library API","title":"Sunny.displacement","text":"displacement(cryst::Crystal, b::Bond)\n\nThe displacement vector ğ«_j - ğ«_i in global coordinates between atoms b.i and b.j, accounting for the integer offsets b.n between unit cells.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.distance-Tuple{Crystal, Sunny.BondRaw}","page":"Library API","title":"Sunny.distance","text":"distance(cryst::Crystal, b::Bond)\n\nThe global distance between atoms in bond b. Equivalent to norm(displacement(cryst, b)).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.dmvec-Tuple{Any}","page":"Library API","title":"Sunny.dmvec","text":"dmvec(D)\n\nRepresentation of the Dzyaloshinskii-Moriya interaction pseudo-vector D as an antisymmetric matrix,\n\n  |  0   Dâ‚ƒ -Dâ‚‚ |\n  | -Dâ‚ƒ  0   Dâ‚ |\n  |  Dâ‚‚ -Dâ‚  0  |\n\nUseful in the context of set_exchange!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.enable_dipole_dipole!-Tuple{System}","page":"Library API","title":"Sunny.enable_dipole_dipole!","text":"enable_dipole_dipole!(sys::System)\n\nEnables long-range dipole-dipole interactions,\n\n    -(Î¼â‚€4Ï€) _ij  (3 (ğŒ_jğ«_ij)(ğŒ_iğ«_ij) - ğŒ_iğŒ_j)  ğ«_ij^3\n\nwhere the sum is over all pairs of spins (singly counted), including periodic images, regularized using the Ewald summation convention. The magnetic moments are ğŒ_i = Î¼_B g ğ’_i where g is the g-factor or g-tensor, and ğ’_i is the spin angular momentum dipole in units of Ä§. The Bohr magneton Î¼_B and vacuum permeability Î¼_0 are physical constants, with numerical values determined by the unit system.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.energy-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.energy","text":"energy(sys::System)\n\nComputes the total system energy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.extend_periodically-Union{Tuple{N}, Tuple{System{N}, Tuple{Int64, Int64, Int64}}} where N","page":"Library API","title":"Sunny.extend_periodically","text":"extend_periodically(sys::System{N}, mults::NTuple{3, Int64}) where N\n\nCreates a new System identical to sys but with each dimension multiplied by the corresponding factor given in the tuple mults. The original spin configuration is simply repeated periodically.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.filter_visited-Union{Tuple{BinnedArray{K, V}}, Tuple{V}, Tuple{K}} where {K, V}","page":"Library API","title":"Sunny.filter_visited","text":"Return only array elements that are visited.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.forces-Union{Tuple{System{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.forces","text":"forces(Array{Vec3}, sys::System)\n\nReturns the effective local field (force) at each site, ğ = -Eğ¬.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.get_intensities-Tuple{StructureFactor, Any, Any}","page":"Library API","title":"Sunny.get_intensities","text":"get_intensities(sf::StructureFactor, qs, mode; interpolation = nothing,\n                   kT = nothing, formfactors = nothing, negative_energies = false)\n\nThe basic function for retrieving ğ’®(ğªÏ‰) information from a StructureFactor. Maps an array of wave vectors qs to an array of structure factor intensities, including an additional energy index. The values of Ï‰ associated with the energy index can be retrieved by calling Ï‰vals. The three coordinates of each wave vector are measured in reciprocal lattice units, i.e., multiples of the reciprocal lattice vectors.\n\nmode: Should be one of :trace, :perp, or :full. Determines an optional   contraction on the indices Î± and Î² of ğ’®^Î±Î²(qÏ‰). Setting   trace yields _Î± ğ’®^Î±Î±(qÏ‰). Setting perp will employ a   polarization correction on the traced value. Setting full will return all   elements ğ’®^Î±Î²(qÏ‰) with contraction.\ninterpolation: Since ğ’®(qÏ‰) is calculated on a finite lattice, data is   only available at discrete wave vectors. By default, Sunny will round a   requested q to the nearest available wave vector. Linear interpolation can   be applied by setting interpolation=:linear.\nkT: If a temperature is provided, the intensities will be rescaled by a   temperature- and Ï‰-dependent classical-to-quantum factor. kT should be   specified when making comparisons with spin wave calculations or   experimental data.\nformfactors: To apply form factor corrections, provide this keyword with a   vector of FormFactors, one for each unique site in the unit cell. Sunny   will symmetry propagate the results to all equivalent sites.\nnegative_energies: If set to true, Sunny will return the periodic   extension of the energy axis. Most users will not want this.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.get_static_intensities-Tuple{StructureFactor, Any, Any}","page":"Library API","title":"Sunny.get_static_intensities","text":"get_static_intensities(sf::StructureFactor, qs, mode; kwargs...)\n\nReturn the static structure factor intensities at wave vectors qs. The functionality is very similar to get_intensities, except the returned array has dimensions identical to qs. The energy axis has been summed out.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.get_temp-Tuple{MetropolisSampler}","page":"Library API","title":"Sunny.get_temp","text":"get_temp(sampler) :: Float64\n\nReturns the temperature of the sampler, as kT.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.init_bounded!-Tuple{WangLandau}","page":"Library API","title":"Sunny.init_bounded!","text":"Initialize system to bounded range of states using throw-away WL sampling run see run!(...) for comments explaining code in init loop.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.intensity_grid-Tuple{StructureFactor, Any}","page":"Library API","title":"Sunny.intensity_grid","text":"intensity_grid(sf::StructureFactor, mode;\n                   bzsize=(1,1,1), negative_energies = false, index_labels = false, kwargs...)\n\nReturns intensities at discrete wave vectors for which there is exact information. Shares all keywords with get_intensities, and provides two additional options:\n\nbzsize: Specifies the number of Brillouin zones to return, given as a 3-tuple of integers.\nindex_labels: If set to true, will return axis label information for the   data, which may be upacked as: (; intensities, qpoints, Ï‰s).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lattice_params-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Library API","title":"Sunny.lattice_params","text":"lattice_params(lat_vecs::Mat3)\n\nCompute the lattice parameters (a b c Î± Î² Î³) for the three lattice vectors provided as columns of lat_vecs. The inverse mapping is lattice_vectors.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.lattice_vectors-NTuple{6, Any}","page":"Library API","title":"Sunny.lattice_vectors","text":"lattice_vectors(a, b, c, Î±, Î², Î³)\n\nReturn the lattice vectors, as columns of the 33 output matrix, that correspond to the conventional unit cell defined by the lattice constants (a b c) and the angles (Î± Î² Î³) in degrees. The inverse mapping is lattice_params.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.nbasis-Tuple{Crystal}","page":"Library API","title":"Sunny.nbasis","text":"nbasis(crystal::Crystal)\n\nNumber of basis positions (sublattices) in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_anisotropy_as_classical_spins-Tuple{Any}","page":"Library API","title":"Sunny.print_anisotropy_as_classical_spins","text":"function print_anisotropy_as_classical_spins(p)\n\nPrints a quantum operator (e.g. linear combination of Stevens operators) as a polynomial of spin expectation values in the classical limit.\n\nSee also print_anisotropy_as_stevens.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_anisotropy_as_stevens-Tuple{Any}","page":"Library API","title":"Sunny.print_anisotropy_as_stevens","text":"function print_anisotropy_as_stevens(p; N)\n\nPrints a quantum operator (e.g. a polynomial of the spin operators ğ’®) as a linear combination of Stevens operators. The parameter N specifies the dimension of the SU(N) representation, corresponding to quantum spin magnitude S = (N-1)2. The special value N = 0 indicates the large-S classical limit.\n\nIn the output, the symbol X denotes the spin operator magnitude squared. Quantum spin operators ğ’® of any finite dimension satisfy X = ğ’®^2 = S (S+1). To take the large-S limit, however, we keep only leading order powers of S, such that X = S^2.\n\nThis function can be useful for understanding the conversions performed internally by set_anisotropy!.\n\nFor the inverse mapping, see print_anisotropy_as_classical_spins.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_bond-Tuple{Crystal, Bond}","page":"Library API","title":"Sunny.print_bond","text":"print_bond(cryst::Crystal, bond::Bond; b_ref::Bond)\n\nPrints symmetry information for bond bond. A symmetry-equivalent reference bond b_ref can optionally be provided to fix the meaning of the coefficients A, B, ...\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_site-Tuple{Any, Any}","page":"Library API","title":"Sunny.print_site","text":"print_site(cryst, i; R=I)\n\nPrint symmetry information for the site i, including allowed g-tensor and allowed anisotropy operator. An optional rotation matrix R can be provided to define the reference frame for expression of the anisotropy.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_suggested_frame-Tuple{Crystal, Int64}","page":"Library API","title":"Sunny.print_suggested_frame","text":"printsuggestedframe(cryst, i; digits=4)\n\nPrint a suggested reference frame, as a rotation matrix R, that can be used as input to print_site(). This is useful to simplify the description of allowed anisotropies.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.print_symmetry_table-Tuple{Crystal, Any}","page":"Library API","title":"Sunny.print_symmetry_table","text":"print_symmetry_table(cryst::Crystal, max_dist)\n\nPrint symmetry information for all equivalence classes of sites and bonds, up to a maximum bond distance of max_dist. Equivalent to calling print_bond(cryst, b) for every bond b in reference_bonds(cryst, max_dist), where Bond(i, i, [0,0,0]) refers to a single site i.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reference_bonds-Tuple{Crystal, Float64}","page":"Library API","title":"Sunny.reference_bonds","text":"reference_bonds(cryst::Crystal, max_dist)\n\nReturns a full list of bonds, one for each symmetry equivalence class, up to distance max_dist. The reference bond b for each equivalence class is selected according to a scoring system that prioritizes simplification of the elements in basis_for_symmetry_allowed_couplings(cryst, b).\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.reset!-Union{Tuple{BinnedArray{K, V}}, Tuple{V}, Tuple{K}} where {K, V}","page":"Library API","title":"Sunny.reset!","text":"Set all values to 0 and if specified, reset all visited flags to false.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.run!-Tuple{WangLandau}","page":"Library API","title":"Sunny.run!","text":"Run a Wang-Landau simulation.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.sample!-Union{Tuple{MetropolisSampler{N}}, Tuple{N}} where N","page":"Library API","title":"Sunny.sample!","text":"sample!(sampler)\n\nSamples sampler.sys to a new state, under the Boltzmann distribution  as defined by sampler.sys.interactions.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Int64}} where N","page":"Library API","title":"Sunny.set_anisotropy!","text":"set_anisotropy!(sys::System, op, i::Int)\n\nSet the single-ion anisotropy for the ith atom of every unit cell, as well as all symmetry-equivalent atoms. The parameter op may be a polynomial in symbolic spin operators ğ’®[Î±], or a linear combination of symbolic Stevens operators ğ’ª[k,q].\n\nThe characters ğ’® and ğ’ª can be copy-pasted from this help message, or typed at a Julia terminal using \\scrS or \\scrO followed by tab-autocomplete.\n\nFor systems with mode=:projected, the anisotropy operators interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(N) mode.\n\nExamples\n\n```julia\n\nAn easy axis anisotropy in the z-direction\n\nset_anisotropy!(sys, -D*ğ’®[3]^3, i)\n\nThe unique quartic single-ion anisotropy for a site with cubic point group\n\nsymmetry\n\nset_anisotropy!(sys, ğ’ª[4,0] + 5ğ’ª[4,4], i)\n\nAn equivalent expression of this quartic anisotropy, up to a constant shift\n\nset_anisotropy!(sys, 20*(ğ’®[1]^4 + ğ’®[2]^4 + ğ’®[3]^4), i)\n\nSee also print_anisotropy_as_stevens.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_exchange!-Union{Tuple{N}, Tuple{System{N}, Any, Bond}} where N","page":"Library API","title":"Sunny.set_exchange!","text":"set_exchange!(sys::System, J, bond::Bond)\n\nSets a 3Ã—3 spin-exchange matrix J along bond, yielding a pairwise interaction energy ğ’_iJ ğ’_j. This interaction will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten. The parameter bond has the form Bond(i, j, offset), where i and j are atom indices within the unit cell, and offset is a displacement in unit cells.\n\nScalar J implies a pure Heisenberg exchange.\n\nAs a convenience, dmvec(D) can be used to construct the antisymmetric part of the exchange, where D is the Dzyaloshinskii-Moriya pseudo-vector. The resulting interaction will be ğƒ(ğ’_iğ’_j).\n\nExamples\n\nusing Sunny, LinearAlgebra\n\n# An explicit exchange matrix\nJ1 = [2 3 0;\n     -3 2 0;\n      0 0 2]\nset_exchange!(sys, J1, bond)\n\n# An equivalent Heisenberg + DM exchange \nJ2 = 2*I + dmvec([0,0,3])\nset_exchange!(sys, J2, bond)\n\nSee also set_exchange_with_biquadratic!, dmvec.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_exchange_with_biquadratic!-Union{Tuple{N}, Tuple{System{N}, Any, Any, Bond}} where N","page":"Library API","title":"Sunny.set_exchange_with_biquadratic!","text":"set_exchange_with_biquadratic!(sys::System, J, Jâ€², bond::Bond)\n\nSets both quadratic and biquadratic exchange interactions along bond, yielding a pairwise energy ğ’_iJ ğ’_j + J (ğ’_iğ’_j)Â². These interactions will be propagated to equivalent bonds in consistency with crystal symmetry. Any previous exchange interactions on these bonds will be overwritten.\n\nFor systems with mode=:projected the biquadratic interactions will automatically be renormalized to achieve maximum consistency with the more variationally accurate SU(N) mode. This renormalization introduces a correction to the quadratic part of the exchange, which is why the two parts must be specified concurrently.\n\nSee also set_exchange!.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_external_field!-Tuple{System, Any}","page":"Library API","title":"Sunny.set_external_field!","text":"set_external_field!(sys::System, B::Vec3)\n\nIntroduce a Zeeman coupling between all spins and an applied magnetic field B.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_local_anisotropy!-Union{Tuple{N}, Tuple{System{N}, MultivariatePolynomials.AbstractPolynomialLike, Any}} where N","page":"Library API","title":"Sunny.set_local_anisotropy!","text":"set_local_anisotropy!(sys::System, op, idx)\n\nSet a single-ion anisotropy for a single spin at idx, in violation of crystal periodicity. No symmetry analysis will be performed.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_local_external_field!-Tuple{System, Any, Any}","page":"Library API","title":"Sunny.set_local_external_field!","text":"set_local_external_field!(sys::System, B::Vec3, idx::CartesianIndex{4})\n\nIntroduce an applied field B localized to a single spin at idx.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.set_temp!-Tuple{MetropolisSampler, Any}","page":"Library API","title":"Sunny.set_temp!","text":"set_temp!(sampler, kT)\n\nChanges the temperature of the sampler to kT.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.step!-Tuple{System{0}, LangevinHeunP}","page":"Library API","title":"Sunny.step!","text":"step!(sys::System, integrator)\n\nAdvance the spin system forward one step using the parameters and integration scheme specified by integrator.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.subcrystal-Union{Tuple{N}, Tuple{Crystal, Vararg{String, N}}} where N","page":"Library API","title":"Sunny.subcrystal","text":"subcrystal(cryst, types) :: Crystal\n\nFilters sublattices of a Crystal by atom types, keeping the space group unchanged.\n\nsubcrystal(cryst, classes) :: Crystal\n\nFilters sublattices of Crystal by equivalence classes, keeping the space group unchanged.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.thermalize!-Union{Tuple{S}, Tuple{S, Int64}} where S<:Sunny.AbstractSampler","page":"Library API","title":"Sunny.thermalize!","text":"thermalize!(sampler, num_samples)\n\nsample! a sampler a given number of times.\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.view_crystal-Tuple{Crystal, Real}","page":"Library API","title":"Sunny.view_crystal","text":"view_crystal(crystal::Crystal, max_dist::Real)\n\nCreate and show crystal viewer in a VSCode or Jupyter notebook environment. The result can also be displayed using browser().\n\n\n\n\n\n","category":"method"},{"location":"library/#Sunny.Ï‰vals-Tuple{StructureFactor}","page":"Library API","title":"Sunny.Ï‰vals","text":"Ï‰vals(sf::StructureFactor)\n\nReturn the Ï‰-values associated with the energy index of a StructureFactor.\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library API","title":"Library API","text":"<!â€“ ","category":"page"},{"location":"library/#Plotting","page":"Library API","title":"Plotting","text":"","category":"section"},{"location":"library/","page":"Library API","title":"Library API","text":"To reduce package load times, Sunny plotting functions are initially hidden, and only become available when the user explicitly executes \"using GLMakie\". It is a good idea to check that the GLMakie installation is working correctly (execute \"] test GLMakie\" from the Julia REPL).","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"plot_lattice\nplot_spins\nplot_bonds\nplot_all_bonds\nanim_integration\nlive_integration\nlive_langevin_integration","category":"page"},{"location":"library/","page":"Library API","title":"Library API","text":"â€“>","category":"page"},{"location":"structure-factor/#Structure-Factor-Calculations","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"","category":"section"},{"location":"structure-factor/#Overview","page":"Structure Factor Calculations","title":"Overview","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The dynamical structure factor is of fundamental importance for characterizing a magnetic system, and facilitates quantitative comparison between theory and experimental scattering data.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Consider, for example, a two-point dynamical spin correlation function, s^Î±(ğ±+Î”ğ± t+Î”t) s^Î²(ğ± t). Here s^Î±(ğ± t) represents the time dynamics of a spin dipole component Î± at position ğ±, and brackets represent an average over equilibrium initial conditions and over (ğ± t). The dynamical structure factor is defined as the Fourier transform of this two-point correlation in both space and time, up to an overall scaling factor. Using the convolution theorem, the result is,","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ğ’®^Î±Î²(ğª Ï‰) = frac1V s^Î±(ğª Ï‰)^ast s^Î²(ğª Ï‰) ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"with V the system volume. We will restrict attention to lattice systems with periodic boundaries.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Consider a crystal unit cell defined by three lattice vectors ğš_1 ğš_2 ğš_3, and linear system sizes L_1 L_2 L_3 measured in unit cells. The allowed momentum vectors take on discrete values ğª = sum_Î±=1^3 m_Î± ğ›_Î±  L_Î±, where m_Î± are an integers and the reciprocal lattice vectors ğ›_Î± are defined to satisfy ğš_Î±  ğ›_Î² = 2Ï€ Î´_Î±Î². For a Bravais lattice, ğª will be periodic in the first Brillouin zone, i.e., under any shift ğª  ğª  ğ›_Î±. More generally, consider a non-Bravais lattice such that each unit cell may contain multiple spins. By partitioning spins s_j(ğ±t) according to their sublattice index j, the relevant momenta ğª remain discretized as above, but now periodicity in the first Brillouin zone is lost. The structure factor may be written as a phase-average over the displacements between sublattices ğ«_jk,","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ğ’®^Î±Î²(ğª Ï‰) = _jk e^i ğ«_jk  ğª ğ’®^Î±Î²_jk(ğª Ï‰) ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"From a theoretical perspective, the quantity","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"ğ’®^Î±Î²_jk(ğª Ï‰) = frac1V s_j^Î±(ğª Ï‰)^ast s_k^Î²(ğª Ï‰)","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"is fundamental. For each sublattice j, the data s_j^Î±(ğª Ï‰) can be efficiently obtained by fast Fourier tranformation of a real space configuration s_j^Î±(ğ± t). Internally, Sunny will calculate and store the discrete ğ’®^Î±Î²_jk(ğª Ï‰) correlation data, and use this to construct ğ’®^Î±Î²(ğª Ï‰) intensities that can be compared with experiment.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Calculating this structure factor involves several steps, with various possible settings. Sunny provides a number of tools to facilitate this calculation and to extract information from the results. These tools are briefly outlined below. \"Real life\" use cases can be found in our tutorials and detailed function information is available in the Library API.","category":"page"},{"location":"structure-factor/#Basic-Usage","page":"Structure Factor Calculations","title":"Basic Usage","text":"","category":"section"},{"location":"structure-factor/#Calculating-a-dynamical-stucture-factor","page":"Structure Factor Calculations","title":"Calculating a dynamical stucture factor","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The basic function for calculating dynamical structure factors is calculate_structure_factor. The steps for using it effectively are the following:","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Build a System and ensure that it is properly equilibrated at the temperature you wish to study. For example, if the System is in a ground state, one could use a LangevinHeunP integrator to thermalize it.\nSet up a sampler that will generate decorrelated samples of spin configurations at the desired temperature, for example, by using a LangevinSampler.\nCall calculate_structure_factor(sys, sampler; kwargs...), which will return a StructureFactor, containing all ğ’®^Î±Î²_jk(ğª Ï‰) data.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The calculation can be configured in a number of ways; see calculate_structure_factor documentation for a list of all keywords. In particular, note that an argument nÏ‰ greater than one must be specified to get a dynamical structure factor.","category":"page"},{"location":"structure-factor/#Extracting-information","page":"Structure Factor Calculations","title":"Extracting information","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The basic function for extracting information from a StructureFactor at a particular wave vector, ğª, is get_intensities. It takes a StructureFactor, a list of wave vectors, and a contraction mode. For example, get_intensities(sf, [[0.0, 0.5, 0.5]], :trace) will calculate intensities for the wavevector ğª = (ğ›_2 + ğ›_3)2. The option :trace will contract spin indices, returning ğ’®^Î±Î±(ğªÏ‰). The option :perp will instead perform a contraction that includes polarization corrections. The option :full will return data for the full tensor ğ’®^Î±Î²(ğªÏ‰). get_intensities returns a list of nÏ‰ elements. The corresponding Ï‰ values are given by Ï‰vals(sf), where sf is the StructureFactor.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"The convenience function connected_path returns a list of wavevectors sampled along a path that connects specified ğª points. This list can be used as an input to get_intensities.","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Since Sunny currently only calculates the structure factor on a finite lattice, it is important to realize that exact information is only available at a discrete set of wave vectors. Specifically, for each axis index i, we will get information at q_i = fracnL_i, where n runs from (frac-L_i2+1) to fracL_i2 and L_i is the linear dimension of the lattice used for the calculation. If you request a wave vector that does not fall in this set, Sunny will automatically round to the nearest ğª that is available. If get_intensities is given the keyword argument interpolation=:linear, Sunny will use trilinear interpolation to determine the results at the requested wave vector. ","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"To retrieve the intensities at all wave vectors for which there is exact data, one can use the function intensity_grid. This takes an optional keyword argument bzsize, which must be given a tuple of three integers specifying the number of Brillouin zones to calculate, e.g., bzsize=(2,2,2).","category":"page"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"Many keyword arguments are available which modify the calculation of structure factor intensity. See the documentation of get_intensities for a full list. It is generally recommended to provide a value to kT corresponding to the temperature of sampled configurations. Given kT, Sunny will apply a classical-to-quantum rescaling of the energy intensities. ","category":"page"},{"location":"structure-factor/#Static-structure-factors","page":"Structure Factor Calculations","title":"Static structure factors","text":"","category":"section"},{"location":"structure-factor/","page":"Structure Factor Calculations","title":"Structure Factor Calculations","text":"A static structure will be calculated if the nÏ‰ keyword of calculate_structure_factor or StructureFactor is left at its default value of 1. Static structure factors may also be calculated from a dynamical structure factor simply by summing over all the energies (i.e., the Ï‰-axis) provided by get_intensities. We recommend calculating static structure factors in this way in most cases (though it is of course much more expensive). The static-from-dynamic approach makes it possible to apply the classical-to-quantum intensity rescaling, which is energy dependent. Sunny provides the function get_static_intensities, which will perform the summation for you.","category":"page"},{"location":"#Sunny.jl","page":"Overview","title":"Sunny.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Sunny is a package for simulating classical spin systems, including the Landau-Lifshitz dynamics of spin dipoles and its generalization to multipolar spin components. In the latter case, Sunny resolves the local quantum structure of individual spins, making it particularly suited for modeling magnetic compounds with strong local anisotropy.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Sunny provides the following features:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Generalization of Landau-Lifshitz spin dynamics using the formalism of SU(N) coherent states.\nAbility specify a crystal by a .cif file, or using its spacegroup symmetry.\nSymmetry analysis to classify allowed Hamiltonian terms, and to automatically populate all symmetry equivalent interactions.\nSingle-ion anisotropy at arbitrary order, which can be specified using Stevens operators or as an arbitrary polynomial of spin operators.\nSampling of spin configurations from the classical Boltzmann distribution at finite-T.\nQuasi-linear scaling dipole-dipole interactions via the fast Fourier transform (FFT) (Langevin mode only).\nMeasurement of mathcalS(mathbfq omega) structure factor data.\nInteractive visualizations of the 3D crystal structure and spin states (support for 3D structure factors is planned.)\nDistributed implementation of parallel tempering to increase sampling efficiency.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A current limitation of Sunny is that it requires real-space dynamical simulations to measure the structure factor, and this limits momentum-space resolution. Support for linear spin wave theory and its SU(N) generalization is in progress.","category":"page"},{"location":"quick-start/#Install-Julia-and-Sunny","page":"Quick Start","title":"Install Julia and Sunny","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Download Julia 1.8 or later. Run the Julia executable, which should open a terminal with the prompt: julia>. Load Sunny with the command:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using Sunny","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"If Sunny has not yet been installed, Julia will ask your permission to download and install it within the Julia environment.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One way to interact with Sunny is through a Jupyter notebook,","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using IJulia\nnotebook()","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"If you see an error about a missing a Julia kernel, you can usually fix this with ] build IJulia from the Julia terminal.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For more information about Julia, see the Getting Started guide.","category":"page"},{"location":"quick-start/#Browse-a-Sunny-notebook","page":"Quick Start","title":"Browse a Sunny notebook","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"To get a feeling for Sunny, a good place to start is the FeI2 case study tutorial notebook. Additional tutorials are available.","category":"page"},{"location":"quick-start/#Example-usage","page":"Quick Start","title":"Example usage","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"At the Julia prompt, create a diamond cubic crystal using the Crystal constructor:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"crystal = Crystal(lattice_vectors(1, 1, 1, 90, 90, 90), [[0,0,0]], 227; setting=\"1\")","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The first argument defines a unit cell via the convenience function lattice_vectors. The second argument is a list of basis atom positions. The third, optional argument specifies an international spacegroup number (if it's missing, Sunny will infer a spacegroup). Arguments appearing after the semicolon ; are named. Here, we are selecting the first (out of two) setting conventions for spacegroup 227.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Sunny outputs:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Crystal\nHM symbol 'F d -3 m' (227)\nLattice params a=1, b=1, c=1, Î±=90Â°, Î²=90Â°, Î³=90Â°\nCell volume 1\nWyckoff 8a (point group '-43m'):\n   1. [0, 0, 0]\n   2. [0.5, 0.5, 0]\n   3. [0.25, 0.25, 0.25]\n   4. [0.75, 0.75, 0.25]\n   5. [0.5, 0, 0.5]\n   6. [0, 0.5, 0.5]\n   7. [0.75, 0.25, 0.75]\n   8. [0.25, 0.75, 0.75]","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Observe that Sunny filled all eight symmetry-equivalent atom positions for the diamond cubic unit cell. The coordinates are measured in units of the lattice vectors.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Alternatively, Sunny can read the crystal structure from a .cif file. Or, if a complete list of atoms is provided, Sunny can infer the spacegroup symmetry using spglib.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The crystal object can be used as an argument to other Sunny functions. For example, print_symmetry_table lists all symmetry-allowed exchange interactions up to a maximum distance,","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"print_symmetry_table(crystal, 0.8)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"which prints,","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Site 1\nPosition [0, 0, 0], multiplicity 8\nAllowed g-tensor: | A  0  0 |\n                  | 0  A  0 |\n                  | 0  0  A |\nAllowed anisotropy in Stevens operators ğ’ª[k,q]:\n    câ‚*(ğ’ª[4,0]+5ğ’ª[4,4]) +\n    câ‚‚*(ğ’ª[6,0]-21ğ’ª[6,4])\n\nBond(1, 3, [0, 0, 0])\nDistance 0.433, coordination 4\nConnects [0, 0, 0] to [0.25, 0.25, 0.25]\nAllowed exchange matrix: | A  B  B |\n                         | B  A  B |\n                         | B  B  A |\n\nBond(1, 2, [0, 0, 0])\nDistance 0.7071, coordination 12\nConnects [0, 0, 0] to [0.5, 0.5, 0]\nAllowed exchange matrix: | A  C -D |\n                         | C  A -D |\n                         | D  D  B |\nAllowed DM vector: [-D D 0]","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Sunny reported that a single-ion anisotropy is only allowed at quartic and hexic orders, which is consistent with the cubic point group symmetry. Additionally, Sunny reported the allowed forms of nearest and next-nearest neighbor interaction.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The next steps are typically the following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Build a System which contains spins on a finite size lattice of crystal unit cells.\nAdd interactions to the system using functions like set_external_field!, set_exchange!, and set_anisotropy!.\nPerform Monte Carlo simulation to equilibrate the spin configuration. The LangevinSampler uses a continuous dynamics whereas MetropolisSampler uses local updates to the spin configuration. The former may be more effective in the presence of strong anisotropy (e.g. the Ising limit) whereas the latter is very efficient at handling long-range dipole-dipole interactions.\nMeasure the static or dynamical structure factor. For details, see the page Structure Factor Calculations.","category":"page"}]
}
