# # LaSrCrO4

using Sunny, GLMakie

# This example demonstrates how to use Sunny's histogram binning
# capabilities. This functionality allows
# the linear spin wave theory data produced by Sunny to be compared to experimental data produced by
# Inelastic Neutron Scattering (INS) in an apples-to-apples fashion.
# Experimental data can be loaded from a `MDHistoWorkspace` stored in a `.nxs` file
# by the [Mantid software](https://www.mantidproject.org/) using [`load_nxs`](@ref).

# For this example, we will use real data from a real INS experiment.
# The data was generated by sending neutrons into a sample, and detecting the momentum and energy transfer of each neutron "event".
# Then, these events were placed into histogram bins[^1] using the Mantid software, and saved into the following `.nxs` files,
# which we load into Sunny:
#
# [^1] Technically, the events were already binned at their conception, since each neutron detector covers a certain angular and time-of-flight *range*. Then, Mantid simply *re*-binned the data onto a coarser histogram.

fn = "60meV"
params_nxs, signal_nxs = load_nxs("../../normData_LaSrCrO4_$(fn)_5K_2D_lowres.nxs")
params_norm_nxs, normalization_nxs = load_nxs("../../normOnly_LaSrCrO4_$(fn)_5K_2D_lowres.nxs")

# The first file contains the experimentally measured probability `signal_nxs` of a neutron scattering according to each bin
# of the histogram described by `params_nxs`:

params_nxs

# The z direction has been integrated over because we are focusing on the intra-layer magnetric structure in this example.

# The values in `signal_nxs` are in arbitrary units, but have been otherwise correctly normalized (by Mantid) to
# account for the differing number of neutrons landing in each bin.
# The other data file contains the normalization factor, `normalization_nxs`, used to carry out that normalization.

# The sample used in the experiment was a crystal of LaSrCrO4 at a temperature of 5 Kelvin.
# Only the Cr atoms in the crystal are magnetic (spin 3/2), and
# the Cr sub-crystal consists of alternating (AB staggered) layers of square lattices.
# We can describe it in Sunny as follows:

a = b = 3.853 # Square lattice spacing
c = 12.475 # Inter-layer spacing
latvecs = lattice_vectors(a,b,c,90,90,90)

## I4/mmm together with latvecs describes the AB staggered square lattice
cryst = Crystal(latvecs, [[0,0,0]], "I4/mmm";types = ["Cr"])

# Observe that this (chemical) unit cell contains one atom at `[0,0,0]` in the A layer, and one
# atom at `[1/2,1/2,1/2]` in the B layer.

# Also note that, because of the way we described the crystal, the lattice vectors are orthogonal:

cryst.latvecs

# These lattice vectors set up the R.L.U. unit system that will be used in the rest of this example.
# The experiment data histograms are also using this same R.L.U. unit system, and in general it
# is important to check that the same units are being used by Sunny and by Mantid.
#
# Next, let's take a peak at the Bragg peaks in the data:

bin_centers = axes_bincenters(params_nxs)
bin_edges = Sunny.axes_binedges(params_nxs)

f = Figure()

energy_bin = 1
ax_left = Axis(f[1,1],xlabel = "Qx [R.L.U.]", ylabel = "Qy [R.L.U.]",
                title = "∫ from $(bin_edges[4][energy_bin]) meV to $(bin_edges[4][energy_bin+1]) meV")
heatmap!(ax_left,bin_centers[1],bin_centers[2],signal_nxs[:,:,1,energy_bin])

energy_bin = 3
ax_right = Axis(f[1,2],xlabel = "Qx [R.L.U.]", ylabel = "Qy [R.L.U.]",
                title = "∫ from $(bin_edges[4][energy_bin]) meV to $(bin_edges[4][energy_bin+1]) meV")

heatmap!(ax_right,bin_centers[1],bin_centers[2],signal_nxs[:,:,1,energy_bin])
f#hide

# The peak at `(1,1)`, most visible on the left panel, is a chemical Bragg peak.
# The fact that it appears at integer coordinates in R.L.U. indicates that we have successfully matched
# units between Mantid and Sunny.
#
# The peaks at half-integer R.L.U. points (e.g. at `(0.5,0.5)`), most visible on the right panel, are
# magnetic Bragg peaks, and they indicate a magnetic ordering with wavevector `[1/2,1/2,0]`, e.g. an
# anti-ferromagnetic Neel state within the layer.
# We can use this information to ask Sunny what a good magnetic super-unit cell might be:

latsize = (1,1,1)
try#hide
suggest_magnetic_supercell([[1/2,1/2,0]], latsize)
catch e#hide
  e#hide
end#hide

# This error means that the 1x1x1 lattice is too small to support the `[1/2,1/2,0]` ordering that
# we have requested. Instead, we must increase the lattice size to fit at least one copy of the
# Neel state unit cell, and try again:

latsize = (2,2,1)
suggest_magnetic_supercell([[1/2,1/2,0]], latsize)

# Now, Sunny makes a good suggestion of a magnetic supercell.
# Let's create a `System` and reshape it into the suggested shape:

S = 3/2 # Cr has spin 3/2 in this system
sys_large = System(cryst, latsize, [SpinInfo(1,S=S,g=2)], :SUN)

## Go to magnetic unit cell for known correct magnetic structure
sys = reshape_supercell(sys_large,[1 1 1; -1 1 0; 0 0 1])

sys.crystal.positions # Print locations of atoms

# This supercell contains four atoms: two on layer A, and two on layer B, enough to
# describe an independent Neel state on each layer.

plot_spins(sys)

# Now that we have set up a nice small system, we can use Linear Spin Wave Theory (LSWT)
# to calculate the scattering intensities.
# How to do this is covered in more detail in other examples, so we just present the code here.
#
# However, it's important to note that the scattering intensity reported by LSWT only
# describes the scattering off of magnons. There is lots of other stuff in the sample
# which neutrons can scatter off of (most notably phonons and chemical Bragg peaks, but also
# defects of all kinds, and even the experimental apparatus itself), so we must carefully
# interpret the results.
#
# The function computing the scattering intensity given the unknown parameters is
# called `forward_problem` because it's the opposite of the so-called "inverse problem" of
# finding the unknown parameters given some data.

## Multi-sampling parameters
## TODO: explanation
lhc4 = [3 3 1; 4 1 2; 2 2 4; 1 4 3]
msaa4 = [(lhc4[i,:] .- 0.5) ./ 4 for i = 1:4]
msaa1 = [[0.5,0.5,0.5]]

function forward_problem(J1,J2,A=0.05; msaa = msaa4, do_energy_msaa = true)
  ## Overwrite all bonds
  set_exchange!(sys,J1,Bond(1,1,[1,0,0])) # Nearest neighbor
  set_exchange!(sys,J2,Bond(1,1,[1,1,0])) # Next-nearest neighbor

  Sop = spin_operators(sys,1)
  set_onsite_coupling!(sys,A*Sop[3]^2,1)

  ## Re-minimize the energy to reflect the updated
  ## ground state based on the updated bonds
  randomize_spins!(sys)
  minimize_energy!(sys)
  minimize_energy!(sys)
  minimize_energy!(sys)

  swt = SpinWaveTheory(sys)
  formula = intensity_formula(swt;
                              ## TODO: instrument-adapted broadening
                              kernel = lorentzian(2.)
                              ## Disable correctness checks for speed
                              ,mode_fast = true
                              ,formfactors = [FormFactor("Cr3")]
                             )

  ## Use histogram parameters from `.nxs` file
  histogram_parameters = params_nxs
  energy_msaa = [0,1/5,2/5,3/5,4/5]

  intensity, counts = Sunny.intensities_bin_multisample(swt,histogram_parameters,msaa,do_energy_msaa ? energy_msaa : [0.5],formula)
  intensity ./ counts
end

# Now, we can call `intensities_sunny = forward_problem(J1,J2)` many times for different values of `J1` and `J2`, 
# and see which `intensities_sunny` comes closest to the experiment data.
# In order for this to work, it is important that `forward_problem` computes intensities on the same grid
# as the experiment data is given on. This is ensured by passing `params_nxs` to `intensities_bin_multisample`.

# Recall that the experiment data is effectively in arbitrary units. This means that we must carefully design the loss
# function to identify the correct rescaling factor to make the intensity scales of the Sunny and experiment data match.
# For this example, we will fix the normalization by asserting that the integral over the `(0.5,0.5)` Bragg peak in the
# 4th energy bin must match between the experiment data and Sunny simulation.
# This a reasonable procedure, since at such a low energy (4-6 meV) and so close to the magnetic Bragg peak, nearly
# all of the scattering is due to magnons, and relatively little is due to e.g. phonons.
# Thus, the Sunny data (magnons only) and experiment data (magnons + tiny amount of other stuff) should be approximately the same
# in that region.
# This function integrates the intensity over the Bragg peak:

function get_Z(is)
  sum(is[7:14,7:14,:,4]) # Qx, Qy, and E range of magnetic bragg peak
end

Z_experiment = get_Z(signal_nxs)

# Now, we can write down an intelligent loss function which accounts for the difference in normalization:

function loss_function(experiment_normalization,experiment_data,simulation_data)
  Z_experiment = get_Z(experiment_data)
  normalized_exp_data = experiment_data ./ Z_experiment

  Z_sunny = get_Z(simulation_data)
  normalized_sim_data = simulation_data ./ Z_sunny
  
  ## We choose weights (of the squared errors) to be inversely proportional to the estimated
  ## variance of the experiment_data. We make the estimate by assuming that each neutron
  ## scattering event is independent, so they follow central limit theorem:
  ##
  ## 1/w ∼ σ² ∼ [1/√N]^2 = 1/N, so w ∼ N
  weights = experiment_normalization

  ## Compute squared error over every histogram bin
  squared_errors = (normalized_exp_data .- normalized_sim_data).^2

  squared_errors[isnan.(squared_errors)] .= 0 # Filter out missing experiment data
  squared_errors[:,:,:,1:2] .= 0 # Filter out chemical bragg peak at low energy

  sqrt(sum(weights .* squared_errors))
end

# The weights used in this loss function bias it to emphasize errors where lots of data was collected,
# since those observations are more statistically reliable than the observations where little data was collected.
#
# With this loss function in place, we can sweep `J1` over a range of values, and see that
# the loss function is (hopefully) minimized at the true value:

J1s = range(7,15,length = 10)
landscape = zeros(Float64,length(J1s))
is_landscape = Vector{Array{Float64,4}}(undef,length(J1s))
for (i1,J1) in enumerate(J1s)
  @time is_landscape[i1] = forward_problem(J1,0.16)
  landscape[i1] = loss_function(normalization_nxs,signal_nxs,is_landscape[i1])
end
plot(landscape)

# To understand how this is working, observe that changing `J1` changes the size of the circles
# in each constant energy slice:

ebin = 20
f = Figure()
ix = 1
ax = Axis(f[1,1],title = "J1 = $(J1s[ix])",aspect = true)
heatmap!(ax,is_landscape[ix][:,:,1,ebin])
ix = 4
ax = Axis(f[1,2],title = "J1 = $(J1s[ix])",aspect = true)
heatmap!(ax,is_landscape[ix][:,:,1,ebin])
ix = 10
ax = Axis(f[1,3],title = "J1 = $(J1s[ix])",aspect = true)
heatmap!(ax,is_landscape[ix][:,:,1,ebin])
ax = Axis(f[2,2],title = "J1 = Experiment",aspect = true)
heatmap!(ax,signal_nxs[:,:,1,ebin])
f

# Further, the "binning effect" is important to account for, and here we do it by multi-sampling.
# If we don't multisample, the circles are much less circular, and the fit is likely to be incorrect:

f = Figure()
ix = 1
is = forward_problem(J1s[ix],0.16;msaa=msaa1,do_energy_msaa = false)
ax = Axis(f[1,1],title = "J1 = $(J1s[ix])",aspect = true)
heatmap!(ax,is[:,:,1,ebin])
ix = 4
is = forward_problem(J1s[ix],0.16;msaa=msaa1,do_energy_msaa = false)
ax = Axis(f[1,2],title = "J1 = $(J1s[ix])",aspect = true)
heatmap!(ax,is[:,:,1,ebin])
ix = 10
is = forward_problem(J1s[ix],0.16;msaa=msaa1,do_energy_msaa = false)
ax = Axis(f[1,3],title = "J1 = $(J1s[ix])",aspect = true)
heatmap!(ax,is[:,:,1,ebin])
ax = Axis(f[2,2],title = "J1 = Experiment",aspect = true)
heatmap!(ax,signal_nxs[:,:,1,ebin])
f

# 


