# # Fitting a Model to Experiment Data in LaSrCrO4

using Sunny, GLMakie

# This example demonstrates how to use Sunny's histogram binning
# capabilities. This functionality allows
# the linear spin wave theory data produced by Sunny to be compared to experimental data produced by
# Inelastic Neutron Scattering (INS) in an apples-to-apples fashion.
# Experimental data can be loaded from a `MDHistoWorkspace` stored in a `.nxs` file
# by the [Mantid software](https://www.mantidproject.org/) using [`load_nxs`](@ref).

# For this example, we will use real data from a real INS experiment.
# The data was generated by sending neutrons into a sample, and detecting the momentum and energy transfer of each neutron "event".
# Then, these events were placed into histogram bins[^1] using the Mantid software, and saved into the following `.nxs` files,
# which we load into Sunny:
#
# [^1] Technically, the events were already binned at their conception, since each neutron detector covers a certain angular and time-of-flight *range*. Then, Mantid simply *re*-binned the data onto a coarser histogram.

fn = "60meV"
params_nxs, signal_nxs = load_nxs("../../normData_LaSrCrO4_$(fn)_5K_2D_lowres.nxs")
params_norm_nxs, normalization_nxs = load_nxs("../../normOnly_LaSrCrO4_$(fn)_5K_2D_lowres.nxs")
nothing#hide

# The warnings here have to do with the availability (or lack thereof) of certain fields in the `.nxs` data files.
# In this case, Sunny has defaulted to parsing the axis labels, e.g. `"[H,0,0]"` in the file becomes the Qx-axis in the histogram.

# The first file contains the experimentally measured probability `signal_nxs` of a neutron scattering according to each bin
# of the histogram described by `params_nxs`:

params_nxs

# The z direction has been integrated over because we are focusing on the intra-layer magnetric structure in this example.

# The values in `signal_nxs` are in arbitrary units, but have been otherwise correctly normalized (by Mantid) to
# account for the differing number of neutrons landing in each bin.
# The other data file contains the normalization factor, `normalization_nxs`, used to carry out that normalization.

# The sample used in the experiment was a crystal of LaSrCrO4 at a temperature of 5 Kelvin.
# Only the Cr atoms in the crystal are magnetic (spin 3/2), and
# the Cr sub-crystal consists of alternating (AB staggered) layers of square lattices.
# We can describe it in Sunny as follows:

a = b = 3.853 # Square lattice spacing
c = 12.475 # Inter-layer spacing
latvecs = lattice_vectors(a,b,c,90,90,90)

## I4/mmm together with latvecs describes the AB staggered square lattice
cryst = Crystal(latvecs, [[0,0,0]], "I4/mmm";types = ["Cr"])

# Observe that this (chemical) unit cell contains one atom at `[0,0,0]` in the A layer, and one
# atom at `[1/2,1/2,1/2]` in the B layer.

# Also note that, because of the way we described the crystal, the lattice vectors are orthogonal:

cryst.latvecs

# These lattice vectors set up the R.L.U. unit system that will be used in the rest of this example.
# The experiment data histograms are also using this same R.L.U. unit system, and in general it
# is important to check that the same units are being used by Sunny and by Mantid.
#
# Next, let's take a peak at the Bragg peaks in the data:

bin_centers = axes_bincenters(params_nxs)
bin_edges = Sunny.axes_binedges(params_nxs)

f = Figure()

energy_bin = 1
ax_left = Axis(f[1,1],xlabel = "Qx [R.L.U.]", ylabel = "Qy [R.L.U.]",
                title = "∫ from $(bin_edges[4][energy_bin]) meV to $(bin_edges[4][energy_bin+1]) meV")
heatmap!(ax_left,bin_centers[1],bin_centers[2],signal_nxs[:,:,1,energy_bin])

energy_bin = 3
ax_right = Axis(f[1,2],xlabel = "Qx [R.L.U.]", ylabel = "Qy [R.L.U.]",
                title = "∫ from $(bin_edges[4][energy_bin]) meV to $(bin_edges[4][energy_bin+1]) meV")

heatmap!(ax_right,bin_centers[1],bin_centers[2],signal_nxs[:,:,1,energy_bin])
f#hide

# The peak at `(1,1)`, most visible on the left panel, is a chemical Bragg peak.
# The fact that it appears at integer coordinates in R.L.U. indicates that we have successfully matched
# units between Mantid and Sunny.
#
# The peaks at half-integer R.L.U. points (e.g. at `(0.5,0.5)`), most visible on the right panel, are
# magnetic Bragg peaks, and they indicate a magnetic ordering with wavevector `[1/2,1/2,0]`, e.g. an
# anti-ferromagnetic Neel state within the layer.
# We can use this information to ask Sunny what a good magnetic super-unit cell might be:

latsize = (1,1,1)
try#hide
suggest_magnetic_supercell([[1/2,1/2,0]], latsize)
catch e#hide
  e#hide
end#hide

# This error means that the 1x1x1 lattice is too small to support the `[1/2,1/2,0]` ordering that
# we have requested. Instead, we must increase the lattice size to fit at least one copy of the
# Neel state unit cell, and try again:

latsize = (2,2,1)
suggest_magnetic_supercell([[1/2,1/2,0]], latsize)

# Now, Sunny makes a good suggestion of a magnetic supercell.
# Let's create a `System` and reshape it into the suggested shape:

S = 3/2 # Cr has spin 3/2 in this system
sys_large = System(cryst, latsize, [SpinInfo(1,S=S,g=2)], :SUN)

## Go to magnetic unit cell for known correct magnetic structure
sys = reshape_supercell(sys_large,[1 1 1; -1 1 0; 0 0 1])

sys.crystal.positions # Print locations of atoms

# This supercell contains four atoms: two on layer A, and two on layer B, enough to
# describe an independent Neel state on each layer.

plot_spins(sys)

# Now that we have set up a nice small system, we can use Linear Spin Wave Theory (LSWT)
# to calculate the scattering intensities.
# How to do this is covered in more detail in other examples, so we just present the code here.
#
# However, it's important to note that the scattering intensity reported by LSWT only
# describes the scattering off of magnons. There is lots of other stuff in the sample
# which neutrons can scatter off of (most notably phonons and chemical Bragg peaks, but also
# defects of all kinds, and even the experimental apparatus itself), so we must carefully
# interpret the results.
#
# The function computing the scattering intensity given the unknown parameters is
# called `forward_problem` because it's the opposite of the so-called "inverse problem" of
# finding the unknown parameters given some data.

# !!! note "Multi-sampling"
#     
#     Since the bins of the experiment data have a finite width, it's important to account for this
#     fact when calculating the theoretical intensity for the bin. We will do this by taking multiple
#     within each bin. This is specified by a "multi-sampling strategy," a list of the fractional positions
#     of the sample points within the bin. Sampling more points is more computationally intensive, but also more accurate.
#     Three multi-sampling strategies of varying resolution are shown in different colors below.


## Multi-sampling parameters
lhc16 = [7 7 5; 3 2 10; 5 13 2; 10 12 13; 14 10 6; 13 11 3; 8 5 11; 1 16 1; 15 9 9; 2 6 12; 12 3 4; 4 8 8; 16 15 15; 9 14 7; 6 4 14; 11 1 16]
msaa16 = [(lhc16[i,:] .- 0.5) ./ 16 for i = 1:16]

lhc4 = [3 3 1; 4 1 2; 2 2 4; 1 4 3]
msaa4 = [(lhc4[i,:] .- 0.5) ./ 4 for i = 1:4]

msaa1 = [[0.5,0.5,0.5]]

f = Figure()#hide
ax = Axis3(f[1,1])#hide
for (msaa,c) in zip([msaa1,msaa4,msaa16],[:red,:blue,:green])
  x = [p[1] for p in msaa]
  y = [p[2] for p in msaa]
  z = [p[3] for p in msaa]
  scatter!(ax,x,y,z,color = c)
end
f#hide

#

function forward_problem(J1,J2 = 0.16,A=0.05;
    msaa = msaa4, do_energy_msaa = true, # Use 4x multisample by default
    histogram_parameters = params_nxs # Use histogram parameters from `.nxs` file by default
  )
  ## Overwrite all bonds
  set_exchange!(sys,J1,Bond(1,1,[1,0,0])) # Nearest neighbor
  set_exchange!(sys,J2,Bond(1,1,[1,1,0])) # Next-nearest neighbor

  Sop = spin_operators(sys,1)
  set_onsite_coupling!(sys,A*Sop[3]^2,1)

  ## Re-minimize the energy to reflect the updated
  ## ground state based on the updated bonds
  randomize_spins!(sys)
  minimize_energy!(sys)
  minimize_energy!(sys)
  minimize_energy!(sys)

  swt = SpinWaveTheory(sys)
  formula = intensity_formula(swt;
                              ## TODO: instrument-adapted broadening
                              kernel = lorentzian(2.)
                              ## Disable correctness checks for speed
                              ,mode_fast = true
                              ,formfactors = [FormFactor("Cr3")]
                             )

  energy_msaa = [0,1/5,2/5,3/5,4/5]

  intensity, counts = Sunny.intensities_bin_multisample(swt,histogram_parameters,msaa,do_energy_msaa ? energy_msaa : [0.5],formula)
  intensity ./ counts
end

# Now, we can call `intensities_sunny = forward_problem(J1,J2)` many times for different values of `J1` and `J2`, 
# and see which `intensities_sunny` comes closest to the experiment data.
# In order for this to work, it is important that `forward_problem` computes intensities on the same grid
# as the experiment data is given on. This is ensured by passing `params_nxs` to `intensities_bin_multisample`.

# Recall that the experiment data is effectively in arbitrary units. This means that we must carefully design the loss
# function to identify the correct rescaling factor to make the intensity scales of the Sunny and experiment data match.
# For this example, we will fix the normalization by asserting that the integral over the `(0.5,0.5)` Bragg peak in the
# 4th energy bin must match between the experiment data and Sunny simulation.
# This a reasonable procedure, since at such a low energy (4-6 meV) and so close to the magnetic Bragg peak, nearly
# all of the scattering is due to magnons, and relatively little is due to e.g. phonons.
# Thus, the Sunny data (magnons only) and experiment data (magnons + tiny amount of other stuff) should be approximately the same
# in that region.
# This function integrates the intensity over the Bragg peak:

function get_Z(is)
  sum(is[7:14,7:14,:,4]) # Qx, Qy, and E range of magnetic bragg peak
end

Z_experiment = get_Z(signal_nxs)

# Now, we can write down an intelligent loss function which accounts for the difference in normalization:

function loss_function(experiment_normalization,experiment_data,simulation_data)
  Z_experiment = get_Z(experiment_data)
  normalized_exp_data = experiment_data ./ Z_experiment

  Z_sunny = get_Z(simulation_data)
  normalized_sim_data = simulation_data ./ Z_sunny
  
  ## We choose weights (of the squared errors) to be inversely proportional to the estimated
  ## variance of the experiment_data. We make the estimate by assuming that each neutron
  ## scattering event is independent, so they follow central limit theorem:
  ##
  ## 1/w ∼ σ² ∼ [1/√N]^2 = 1/N, so w ∼ N
  weights = experiment_normalization

  ## Compute squared error over every histogram bin
  squared_errors = (normalized_exp_data .- normalized_sim_data).^2

  squared_errors[isnan.(squared_errors)] .= 0 # Filter out missing experiment data
  squared_errors[:,:,:,1:2] .= 0 # Filter out chemical bragg peak at low energy

  sqrt(sum(weights .* squared_errors))
end

# The weights used in this loss function bias it to emphasize errors where lots of data was collected,
# since those observations are more statistically reliable than the observations where little data was collected.
#
# With this loss function in place, we can sweep `J1` over a range of values, and see that
# the loss function is (hopefully) minimized at the true value:

J1s = range(9,12,length = 10)
landscape = zeros(Float64,length(J1s))
is_landscape = Vector{Array{Float64,4}}(undef,length(J1s))
for (i1,J1) in enumerate(J1s)
  @time is_landscape[i1] = forward_problem(J1)
  landscape[i1] = loss_function(normalization_nxs,signal_nxs,is_landscape[i1])
end
plot(J1s,landscape)

# At the time of this writing, each data point on the graph costs about 4 seconds to compute.

# To understand how this is working, observe that changing `J1` changes the size of the circles
# in any given constant energy slice:

energy_bin = 20 # Fix a particular constant-energy slice
f = Figure()#hide
ix = 1#hide
ax = Axis(f[1,1],title = "J1 = $(J1s[ix])",aspect = true)#hide
heatmap!(ax,bin_centers[1],bin_centers[2],is_landscape[ix][:,:,1,energy_bin])#hide
ix = 4#hide
ax = Axis(f[1,2],title = "J1 = $(J1s[ix])",aspect = true)#hide
heatmap!(ax,bin_centers[1],bin_centers[2],is_landscape[ix][:,:,1,energy_bin])#hide
ix = 10#hide
ax = Axis(f[1,3],title = "J1 = $(J1s[ix])",aspect = true)#hide
heatmap!(ax,bin_centers[1],bin_centers[2],is_landscape[ix][:,:,1,energy_bin])#hide
ax = Axis(f[2,2],title = "J1 = Experiment",aspect = true)#hide
heatmap!(ax,bin_centers[1],bin_centers[2],signal_nxs[:,:,1,energy_bin])#hide
f#hide

# Thus, the fit is expressing that the circles for the correct `J1` should match the size seen in the experiment.

# ## Binning Effects

# It's very important to choose a multi-sampling strategy which is appropriate for the size and level of
# detail of the bins in a histogram.
# For example, if we didn't multisample, the circles are much less circular, and the fit is likely to be incorrect:

f = Figure()#hide
ix = 1#hide
## Re-compute with 1x msaa and no multi-sampling in energy...
is = forward_problem(J1s[ix];msaa=msaa1,do_energy_msaa = false)#hide
ax = Axis(f[1,1],title = "J1 = $(J1s[ix])",aspect = true)#hide
heatmap!(ax,bin_centers[1],bin_centers[2],is[:,:,1,energy_bin])#hide
ix = 4#hide
is = forward_problem(J1s[ix];msaa=msaa1,do_energy_msaa = false)#hide
ax = Axis(f[1,2],title = "J1 = $(J1s[ix])",aspect = true)#hide
heatmap!(ax,bin_centers[1],bin_centers[2],is[:,:,1,energy_bin])#hide
ix = 10#hide
is = forward_problem(J1s[ix];msaa=msaa1,do_energy_msaa = false)#hide
ax = Axis(f[1,3],title = "J1 = $(J1s[ix])",aspect = true)#hide
heatmap!(ax,bin_centers[1],bin_centers[2],is[:,:,1,energy_bin])#hide
ax = Axis(f[2,2],title = "J1 = Experiment",aspect = true)#hide
heatmap!(ax,bin_centers[1],bin_centers[2],signal_nxs[:,:,1,energy_bin])#hide
lines!(ax,[Point2f([0.75,h]) for h in [0,1]],linestyle=:dash,color = :red)#hide
f#hide


# In other cases, the choice of bin width can impact the qualitative interpretation of the data.
# For example, consider a 2D QE slice `[0.75,H,0]` parameterized by H (red dashed line above).
# This slice passes nearby, but not through, the ordering wavevector `[0.5,0.5,0]`.
# As a result, the bands are highly dispersive (meaning ``\frac{\partial\omega}{\partial Q_x}`` is large) near ``H = 0.5``.
# For small tranverse bins ``\Delta Q_x``, there is a binning effect "broadening" of the bands on the order of ``\frac{\partial\omega}{\partial Q_x} \Delta Q_x``, as seen below:

ff = Figure()#hide
energies = axes_bincenters(params_nxs)[4]
for (i,width) in enumerate(10 .^ range(-2,0,length = 6))
  params = slice_2D_binning_parameters(energies,[0.75,0,0],[0.75,1,0],50,width;cut_height = 10.)
  msaa = [[0,dy,0] for dy in range(0,1,length = 32)] # 32x msaa in the transverse direction
  is = forward_problem(10.6; msaa, histogram_parameters = params) # True value of J1
  bcs = axes_bincenters(params)
  ax = if mod(i-1,3) == 0#hide
    Axis(ff[(i-1)÷3 + 1,1],xlabel = "[0.75,H,0]", title = "ΔQx ≈ $(round(width,sigdigits=3))", ylabel = "Energy [meV]", aspect = true)#hide
  else#hide
    Axis(ff[(i-1) ÷ 3 + 1, mod(i - 1,3) + 1],xlabel = "[0.75,H,0]", title = "ΔQx ≈ $(round(width,sigdigits=3))", yticklabelsvisible = false, aspect = true)#hide
  end#hide
  heatmap!(ax,bcs[1],bcs[4],is[:,1,1,:])
end
ff#hide

# The ``\Delta Q_x \approx 0.158`` panel in particular looks like it could be exotic fractional spin excitations,
# with a continuous range of energies possible for each ``Q``, but in fact the broadening is simply due to the binning effect.


